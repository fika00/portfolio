import {
  BlendFunction,
  BloomEffect,
  BrightnessContrastEffect,
  ChromaticAberrationEffect,
  ColorAverageEffect,
  ColorDepthEffect,
  CopyPass,
  DepthDownsamplingPass,
  DepthEffect,
  DepthOfFieldEffect,
  DepthPass,
  DepthPickingPass,
  DotScreenEffect,
  Effect,
  EffectAttribute,
  EffectComposer,
  EffectPass,
  GlitchEffect,
  GlitchMode,
  GodRaysEffect,
  GridEffect,
  HueSaturationEffect,
  LUT3DEffect,
  MaskFunction,
  NoiseEffect,
  NormalPass,
  OutlineEffect,
  Pass,
  PixelationEffect,
  RenderPass,
  SMAAEffect,
  SSAOEffect,
  ScanlineEffect,
  Selection,
  SelectiveBloomEffect,
  SepiaEffect,
  ShockWaveEffect,
  TextureEffect,
  TiltShiftEffect,
  ToneMappingEffect,
  VignetteEffect
} from "./chunk-5THTFVEL.js";
import {
  easing,
  isWebGL2Available
} from "./chunk-2X2CE3R7.js";
import "./chunk-LNW67B6E.js";
import {
  createPortal,
  extend,
  useFrame,
  useInstanceHandle,
  useLoader,
  useThree
} from "./chunk-PVTG5RSR.js";
import {
  Color,
  CubeCamera,
  DataTexture,
  FloatType,
  FramebufferTexture,
  GLSL3,
  HalfFloatType,
  LinearFilter,
  Matrix3,
  Matrix4,
  NearestFilter,
  PMREMGenerator,
  Quaternion,
  RGBAFormat,
  RepeatWrapping,
  ShaderChunk,
  ShaderMaterial,
  TangentSpaceNormalMap,
  Texture,
  TextureLoader,
  Uniform,
  Vector2,
  Vector3,
  VideoTexture,
  WebGLCubeRenderTarget,
  WebGLMultipleRenderTargets,
  WebGLRenderTarget,
  sRGBEncoding
} from "./chunk-7SDWBFEO.js";
import "./chunk-MQF4LD5M.js";
import "./chunk-KBUAZBQ3.js";
import {
  require_react
} from "./chunk-C3MNZ72B.js";
import {
  __commonJS,
  __toESM
} from "./chunk-JEXKZRFY.js";

// node_modules/react/cjs/react-jsx-runtime.development.js
var require_react_jsx_runtime_development = __commonJS({
  "node_modules/react/cjs/react-jsx-runtime.development.js"(exports) {
    "use strict";
    if (true) {
      (function() {
        "use strict";
        var React2 = require_react();
        var REACT_ELEMENT_TYPE = Symbol.for("react.element");
        var REACT_PORTAL_TYPE = Symbol.for("react.portal");
        var REACT_FRAGMENT_TYPE = Symbol.for("react.fragment");
        var REACT_STRICT_MODE_TYPE = Symbol.for("react.strict_mode");
        var REACT_PROFILER_TYPE = Symbol.for("react.profiler");
        var REACT_PROVIDER_TYPE = Symbol.for("react.provider");
        var REACT_CONTEXT_TYPE = Symbol.for("react.context");
        var REACT_FORWARD_REF_TYPE = Symbol.for("react.forward_ref");
        var REACT_SUSPENSE_TYPE = Symbol.for("react.suspense");
        var REACT_SUSPENSE_LIST_TYPE = Symbol.for("react.suspense_list");
        var REACT_MEMO_TYPE = Symbol.for("react.memo");
        var REACT_LAZY_TYPE = Symbol.for("react.lazy");
        var REACT_OFFSCREEN_TYPE = Symbol.for("react.offscreen");
        var MAYBE_ITERATOR_SYMBOL = Symbol.iterator;
        var FAUX_ITERATOR_SYMBOL = "@@iterator";
        function getIteratorFn(maybeIterable) {
          if (maybeIterable === null || typeof maybeIterable !== "object") {
            return null;
          }
          var maybeIterator = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL];
          if (typeof maybeIterator === "function") {
            return maybeIterator;
          }
          return null;
        }
        var ReactSharedInternals = React2.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
        function error(format) {
          {
            {
              for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
                args[_key2 - 1] = arguments[_key2];
              }
              printWarning("error", format, args);
            }
          }
        }
        function printWarning(level, format, args) {
          {
            var ReactDebugCurrentFrame2 = ReactSharedInternals.ReactDebugCurrentFrame;
            var stack = ReactDebugCurrentFrame2.getStackAddendum();
            if (stack !== "") {
              format += "%s";
              args = args.concat([stack]);
            }
            var argsWithFormat = args.map(function(item) {
              return String(item);
            });
            argsWithFormat.unshift("Warning: " + format);
            Function.prototype.apply.call(console[level], console, argsWithFormat);
          }
        }
        var enableScopeAPI = false;
        var enableCacheElement = false;
        var enableTransitionTracing = false;
        var enableLegacyHidden = false;
        var enableDebugTracing = false;
        var REACT_MODULE_REFERENCE;
        {
          REACT_MODULE_REFERENCE = Symbol.for("react.module.reference");
        }
        function isValidElementType(type) {
          if (typeof type === "string" || typeof type === "function") {
            return true;
          }
          if (type === REACT_FRAGMENT_TYPE || type === REACT_PROFILER_TYPE || enableDebugTracing || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || enableLegacyHidden || type === REACT_OFFSCREEN_TYPE || enableScopeAPI || enableCacheElement || enableTransitionTracing) {
            return true;
          }
          if (typeof type === "object" && type !== null) {
            if (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || // This needs to include all possible module reference object
            // types supported by any Flight configuration anywhere since
            // we don't know which Flight build this will end up being used
            // with.
            type.$$typeof === REACT_MODULE_REFERENCE || type.getModuleId !== void 0) {
              return true;
            }
          }
          return false;
        }
        function getWrappedName(outerType, innerType, wrapperName) {
          var displayName = outerType.displayName;
          if (displayName) {
            return displayName;
          }
          var functionName = innerType.displayName || innerType.name || "";
          return functionName !== "" ? wrapperName + "(" + functionName + ")" : wrapperName;
        }
        function getContextName(type) {
          return type.displayName || "Context";
        }
        function getComponentNameFromType(type) {
          if (type == null) {
            return null;
          }
          {
            if (typeof type.tag === "number") {
              error("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue.");
            }
          }
          if (typeof type === "function") {
            return type.displayName || type.name || null;
          }
          if (typeof type === "string") {
            return type;
          }
          switch (type) {
            case REACT_FRAGMENT_TYPE:
              return "Fragment";
            case REACT_PORTAL_TYPE:
              return "Portal";
            case REACT_PROFILER_TYPE:
              return "Profiler";
            case REACT_STRICT_MODE_TYPE:
              return "StrictMode";
            case REACT_SUSPENSE_TYPE:
              return "Suspense";
            case REACT_SUSPENSE_LIST_TYPE:
              return "SuspenseList";
          }
          if (typeof type === "object") {
            switch (type.$$typeof) {
              case REACT_CONTEXT_TYPE:
                var context = type;
                return getContextName(context) + ".Consumer";
              case REACT_PROVIDER_TYPE:
                var provider = type;
                return getContextName(provider._context) + ".Provider";
              case REACT_FORWARD_REF_TYPE:
                return getWrappedName(type, type.render, "ForwardRef");
              case REACT_MEMO_TYPE:
                var outerName = type.displayName || null;
                if (outerName !== null) {
                  return outerName;
                }
                return getComponentNameFromType(type.type) || "Memo";
              case REACT_LAZY_TYPE: {
                var lazyComponent = type;
                var payload = lazyComponent._payload;
                var init = lazyComponent._init;
                try {
                  return getComponentNameFromType(init(payload));
                } catch (x) {
                  return null;
                }
              }
            }
          }
          return null;
        }
        var assign = Object.assign;
        var disabledDepth = 0;
        var prevLog;
        var prevInfo;
        var prevWarn;
        var prevError;
        var prevGroup;
        var prevGroupCollapsed;
        var prevGroupEnd;
        function disabledLog() {
        }
        disabledLog.__reactDisabledLog = true;
        function disableLogs() {
          {
            if (disabledDepth === 0) {
              prevLog = console.log;
              prevInfo = console.info;
              prevWarn = console.warn;
              prevError = console.error;
              prevGroup = console.group;
              prevGroupCollapsed = console.groupCollapsed;
              prevGroupEnd = console.groupEnd;
              var props = {
                configurable: true,
                enumerable: true,
                value: disabledLog,
                writable: true
              };
              Object.defineProperties(console, {
                info: props,
                log: props,
                warn: props,
                error: props,
                group: props,
                groupCollapsed: props,
                groupEnd: props
              });
            }
            disabledDepth++;
          }
        }
        function reenableLogs() {
          {
            disabledDepth--;
            if (disabledDepth === 0) {
              var props = {
                configurable: true,
                enumerable: true,
                writable: true
              };
              Object.defineProperties(console, {
                log: assign({}, props, {
                  value: prevLog
                }),
                info: assign({}, props, {
                  value: prevInfo
                }),
                warn: assign({}, props, {
                  value: prevWarn
                }),
                error: assign({}, props, {
                  value: prevError
                }),
                group: assign({}, props, {
                  value: prevGroup
                }),
                groupCollapsed: assign({}, props, {
                  value: prevGroupCollapsed
                }),
                groupEnd: assign({}, props, {
                  value: prevGroupEnd
                })
              });
            }
            if (disabledDepth < 0) {
              error("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
            }
          }
        }
        var ReactCurrentDispatcher = ReactSharedInternals.ReactCurrentDispatcher;
        var prefix;
        function describeBuiltInComponentFrame(name, source, ownerFn) {
          {
            if (prefix === void 0) {
              try {
                throw Error();
              } catch (x) {
                var match = x.stack.trim().match(/\n( *(at )?)/);
                prefix = match && match[1] || "";
              }
            }
            return "\n" + prefix + name;
          }
        }
        var reentry = false;
        var componentFrameCache;
        {
          var PossiblyWeakMap = typeof WeakMap === "function" ? WeakMap : Map;
          componentFrameCache = new PossiblyWeakMap();
        }
        function describeNativeComponentFrame(fn, construct) {
          if (!fn || reentry) {
            return "";
          }
          {
            var frame = componentFrameCache.get(fn);
            if (frame !== void 0) {
              return frame;
            }
          }
          var control;
          reentry = true;
          var previousPrepareStackTrace = Error.prepareStackTrace;
          Error.prepareStackTrace = void 0;
          var previousDispatcher;
          {
            previousDispatcher = ReactCurrentDispatcher.current;
            ReactCurrentDispatcher.current = null;
            disableLogs();
          }
          try {
            if (construct) {
              var Fake = function() {
                throw Error();
              };
              Object.defineProperty(Fake.prototype, "props", {
                set: function() {
                  throw Error();
                }
              });
              if (typeof Reflect === "object" && Reflect.construct) {
                try {
                  Reflect.construct(Fake, []);
                } catch (x) {
                  control = x;
                }
                Reflect.construct(fn, [], Fake);
              } else {
                try {
                  Fake.call();
                } catch (x) {
                  control = x;
                }
                fn.call(Fake.prototype);
              }
            } else {
              try {
                throw Error();
              } catch (x) {
                control = x;
              }
              fn();
            }
          } catch (sample) {
            if (sample && control && typeof sample.stack === "string") {
              var sampleLines = sample.stack.split("\n");
              var controlLines = control.stack.split("\n");
              var s = sampleLines.length - 1;
              var c = controlLines.length - 1;
              while (s >= 1 && c >= 0 && sampleLines[s] !== controlLines[c]) {
                c--;
              }
              for (; s >= 1 && c >= 0; s--, c--) {
                if (sampleLines[s] !== controlLines[c]) {
                  if (s !== 1 || c !== 1) {
                    do {
                      s--;
                      c--;
                      if (c < 0 || sampleLines[s] !== controlLines[c]) {
                        var _frame = "\n" + sampleLines[s].replace(" at new ", " at ");
                        if (fn.displayName && _frame.includes("<anonymous>")) {
                          _frame = _frame.replace("<anonymous>", fn.displayName);
                        }
                        {
                          if (typeof fn === "function") {
                            componentFrameCache.set(fn, _frame);
                          }
                        }
                        return _frame;
                      }
                    } while (s >= 1 && c >= 0);
                  }
                  break;
                }
              }
            }
          } finally {
            reentry = false;
            {
              ReactCurrentDispatcher.current = previousDispatcher;
              reenableLogs();
            }
            Error.prepareStackTrace = previousPrepareStackTrace;
          }
          var name = fn ? fn.displayName || fn.name : "";
          var syntheticFrame = name ? describeBuiltInComponentFrame(name) : "";
          {
            if (typeof fn === "function") {
              componentFrameCache.set(fn, syntheticFrame);
            }
          }
          return syntheticFrame;
        }
        function describeFunctionComponentFrame(fn, source, ownerFn) {
          {
            return describeNativeComponentFrame(fn, false);
          }
        }
        function shouldConstruct(Component) {
          var prototype = Component.prototype;
          return !!(prototype && prototype.isReactComponent);
        }
        function describeUnknownElementTypeFrameInDEV(type, source, ownerFn) {
          if (type == null) {
            return "";
          }
          if (typeof type === "function") {
            {
              return describeNativeComponentFrame(type, shouldConstruct(type));
            }
          }
          if (typeof type === "string") {
            return describeBuiltInComponentFrame(type);
          }
          switch (type) {
            case REACT_SUSPENSE_TYPE:
              return describeBuiltInComponentFrame("Suspense");
            case REACT_SUSPENSE_LIST_TYPE:
              return describeBuiltInComponentFrame("SuspenseList");
          }
          if (typeof type === "object") {
            switch (type.$$typeof) {
              case REACT_FORWARD_REF_TYPE:
                return describeFunctionComponentFrame(type.render);
              case REACT_MEMO_TYPE:
                return describeUnknownElementTypeFrameInDEV(type.type, source, ownerFn);
              case REACT_LAZY_TYPE: {
                var lazyComponent = type;
                var payload = lazyComponent._payload;
                var init = lazyComponent._init;
                try {
                  return describeUnknownElementTypeFrameInDEV(init(payload), source, ownerFn);
                } catch (x) {
                }
              }
            }
          }
          return "";
        }
        var hasOwnProperty = Object.prototype.hasOwnProperty;
        var loggedTypeFailures = {};
        var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;
        function setCurrentlyValidatingElement(element) {
          {
            if (element) {
              var owner = element._owner;
              var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);
              ReactDebugCurrentFrame.setExtraStackFrame(stack);
            } else {
              ReactDebugCurrentFrame.setExtraStackFrame(null);
            }
          }
        }
        function checkPropTypes(typeSpecs, values, location, componentName, element) {
          {
            var has = Function.call.bind(hasOwnProperty);
            for (var typeSpecName in typeSpecs) {
              if (has(typeSpecs, typeSpecName)) {
                var error$1 = void 0;
                try {
                  if (typeof typeSpecs[typeSpecName] !== "function") {
                    var err = Error((componentName || "React class") + ": " + location + " type `" + typeSpecName + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof typeSpecs[typeSpecName] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                    err.name = "Invariant Violation";
                    throw err;
                  }
                  error$1 = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
                } catch (ex) {
                  error$1 = ex;
                }
                if (error$1 && !(error$1 instanceof Error)) {
                  setCurrentlyValidatingElement(element);
                  error("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", componentName || "React class", location, typeSpecName, typeof error$1);
                  setCurrentlyValidatingElement(null);
                }
                if (error$1 instanceof Error && !(error$1.message in loggedTypeFailures)) {
                  loggedTypeFailures[error$1.message] = true;
                  setCurrentlyValidatingElement(element);
                  error("Failed %s type: %s", location, error$1.message);
                  setCurrentlyValidatingElement(null);
                }
              }
            }
          }
        }
        var isArrayImpl = Array.isArray;
        function isArray(a) {
          return isArrayImpl(a);
        }
        function typeName(value) {
          {
            var hasToStringTag = typeof Symbol === "function" && Symbol.toStringTag;
            var type = hasToStringTag && value[Symbol.toStringTag] || value.constructor.name || "Object";
            return type;
          }
        }
        function willCoercionThrow(value) {
          {
            try {
              testStringCoercion(value);
              return false;
            } catch (e) {
              return true;
            }
          }
        }
        function testStringCoercion(value) {
          return "" + value;
        }
        function checkKeyStringCoercion(value) {
          {
            if (willCoercionThrow(value)) {
              error("The provided key is an unsupported type %s. This value must be coerced to a string before before using it here.", typeName(value));
              return testStringCoercion(value);
            }
          }
        }
        var ReactCurrentOwner = ReactSharedInternals.ReactCurrentOwner;
        var RESERVED_PROPS = {
          key: true,
          ref: true,
          __self: true,
          __source: true
        };
        var specialPropKeyWarningShown;
        var specialPropRefWarningShown;
        var didWarnAboutStringRefs;
        {
          didWarnAboutStringRefs = {};
        }
        function hasValidRef(config) {
          {
            if (hasOwnProperty.call(config, "ref")) {
              var getter = Object.getOwnPropertyDescriptor(config, "ref").get;
              if (getter && getter.isReactWarning) {
                return false;
              }
            }
          }
          return config.ref !== void 0;
        }
        function hasValidKey(config) {
          {
            if (hasOwnProperty.call(config, "key")) {
              var getter = Object.getOwnPropertyDescriptor(config, "key").get;
              if (getter && getter.isReactWarning) {
                return false;
              }
            }
          }
          return config.key !== void 0;
        }
        function warnIfStringRefCannotBeAutoConverted(config, self) {
          {
            if (typeof config.ref === "string" && ReactCurrentOwner.current && self && ReactCurrentOwner.current.stateNode !== self) {
              var componentName = getComponentNameFromType(ReactCurrentOwner.current.type);
              if (!didWarnAboutStringRefs[componentName]) {
                error('Component "%s" contains the string ref "%s". Support for string refs will be removed in a future major release. This case cannot be automatically converted to an arrow function. We ask you to manually fix this case by using useRef() or createRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref', getComponentNameFromType(ReactCurrentOwner.current.type), config.ref);
                didWarnAboutStringRefs[componentName] = true;
              }
            }
          }
        }
        function defineKeyPropWarningGetter(props, displayName) {
          {
            var warnAboutAccessingKey = function() {
              if (!specialPropKeyWarningShown) {
                specialPropKeyWarningShown = true;
                error("%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", displayName);
              }
            };
            warnAboutAccessingKey.isReactWarning = true;
            Object.defineProperty(props, "key", {
              get: warnAboutAccessingKey,
              configurable: true
            });
          }
        }
        function defineRefPropWarningGetter(props, displayName) {
          {
            var warnAboutAccessingRef = function() {
              if (!specialPropRefWarningShown) {
                specialPropRefWarningShown = true;
                error("%s: `ref` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", displayName);
              }
            };
            warnAboutAccessingRef.isReactWarning = true;
            Object.defineProperty(props, "ref", {
              get: warnAboutAccessingRef,
              configurable: true
            });
          }
        }
        var ReactElement = function(type, key, ref, self, source, owner, props) {
          var element = {
            // This tag allows us to uniquely identify this as a React Element
            $$typeof: REACT_ELEMENT_TYPE,
            // Built-in properties that belong on the element
            type,
            key,
            ref,
            props,
            // Record the component responsible for creating this element.
            _owner: owner
          };
          {
            element._store = {};
            Object.defineProperty(element._store, "validated", {
              configurable: false,
              enumerable: false,
              writable: true,
              value: false
            });
            Object.defineProperty(element, "_self", {
              configurable: false,
              enumerable: false,
              writable: false,
              value: self
            });
            Object.defineProperty(element, "_source", {
              configurable: false,
              enumerable: false,
              writable: false,
              value: source
            });
            if (Object.freeze) {
              Object.freeze(element.props);
              Object.freeze(element);
            }
          }
          return element;
        };
        function jsxDEV(type, config, maybeKey, source, self) {
          {
            var propName;
            var props = {};
            var key = null;
            var ref = null;
            if (maybeKey !== void 0) {
              {
                checkKeyStringCoercion(maybeKey);
              }
              key = "" + maybeKey;
            }
            if (hasValidKey(config)) {
              {
                checkKeyStringCoercion(config.key);
              }
              key = "" + config.key;
            }
            if (hasValidRef(config)) {
              ref = config.ref;
              warnIfStringRefCannotBeAutoConverted(config, self);
            }
            for (propName in config) {
              if (hasOwnProperty.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {
                props[propName] = config[propName];
              }
            }
            if (type && type.defaultProps) {
              var defaultProps = type.defaultProps;
              for (propName in defaultProps) {
                if (props[propName] === void 0) {
                  props[propName] = defaultProps[propName];
                }
              }
            }
            if (key || ref) {
              var displayName = typeof type === "function" ? type.displayName || type.name || "Unknown" : type;
              if (key) {
                defineKeyPropWarningGetter(props, displayName);
              }
              if (ref) {
                defineRefPropWarningGetter(props, displayName);
              }
            }
            return ReactElement(type, key, ref, self, source, ReactCurrentOwner.current, props);
          }
        }
        var ReactCurrentOwner$1 = ReactSharedInternals.ReactCurrentOwner;
        var ReactDebugCurrentFrame$1 = ReactSharedInternals.ReactDebugCurrentFrame;
        function setCurrentlyValidatingElement$1(element) {
          {
            if (element) {
              var owner = element._owner;
              var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);
              ReactDebugCurrentFrame$1.setExtraStackFrame(stack);
            } else {
              ReactDebugCurrentFrame$1.setExtraStackFrame(null);
            }
          }
        }
        var propTypesMisspellWarningShown;
        {
          propTypesMisspellWarningShown = false;
        }
        function isValidElement(object) {
          {
            return typeof object === "object" && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;
          }
        }
        function getDeclarationErrorAddendum() {
          {
            if (ReactCurrentOwner$1.current) {
              var name = getComponentNameFromType(ReactCurrentOwner$1.current.type);
              if (name) {
                return "\n\nCheck the render method of `" + name + "`.";
              }
            }
            return "";
          }
        }
        function getSourceInfoErrorAddendum(source) {
          {
            if (source !== void 0) {
              var fileName = source.fileName.replace(/^.*[\\\/]/, "");
              var lineNumber = source.lineNumber;
              return "\n\nCheck your code at " + fileName + ":" + lineNumber + ".";
            }
            return "";
          }
        }
        var ownerHasKeyUseWarning = {};
        function getCurrentComponentErrorInfo(parentType) {
          {
            var info = getDeclarationErrorAddendum();
            if (!info) {
              var parentName = typeof parentType === "string" ? parentType : parentType.displayName || parentType.name;
              if (parentName) {
                info = "\n\nCheck the top-level render call using <" + parentName + ">.";
              }
            }
            return info;
          }
        }
        function validateExplicitKey(element, parentType) {
          {
            if (!element._store || element._store.validated || element.key != null) {
              return;
            }
            element._store.validated = true;
            var currentComponentErrorInfo = getCurrentComponentErrorInfo(parentType);
            if (ownerHasKeyUseWarning[currentComponentErrorInfo]) {
              return;
            }
            ownerHasKeyUseWarning[currentComponentErrorInfo] = true;
            var childOwner = "";
            if (element && element._owner && element._owner !== ReactCurrentOwner$1.current) {
              childOwner = " It was passed a child from " + getComponentNameFromType(element._owner.type) + ".";
            }
            setCurrentlyValidatingElement$1(element);
            error('Each child in a list should have a unique "key" prop.%s%s See https://reactjs.org/link/warning-keys for more information.', currentComponentErrorInfo, childOwner);
            setCurrentlyValidatingElement$1(null);
          }
        }
        function validateChildKeys(node, parentType) {
          {
            if (typeof node !== "object") {
              return;
            }
            if (isArray(node)) {
              for (var i2 = 0; i2 < node.length; i2++) {
                var child = node[i2];
                if (isValidElement(child)) {
                  validateExplicitKey(child, parentType);
                }
              }
            } else if (isValidElement(node)) {
              if (node._store) {
                node._store.validated = true;
              }
            } else if (node) {
              var iteratorFn = getIteratorFn(node);
              if (typeof iteratorFn === "function") {
                if (iteratorFn !== node.entries) {
                  var iterator = iteratorFn.call(node);
                  var step;
                  while (!(step = iterator.next()).done) {
                    if (isValidElement(step.value)) {
                      validateExplicitKey(step.value, parentType);
                    }
                  }
                }
              }
            }
          }
        }
        function validatePropTypes(element) {
          {
            var type = element.type;
            if (type === null || type === void 0 || typeof type === "string") {
              return;
            }
            var propTypes;
            if (typeof type === "function") {
              propTypes = type.propTypes;
            } else if (typeof type === "object" && (type.$$typeof === REACT_FORWARD_REF_TYPE || // Note: Memo only checks outer props here.
            // Inner props are checked in the reconciler.
            type.$$typeof === REACT_MEMO_TYPE)) {
              propTypes = type.propTypes;
            } else {
              return;
            }
            if (propTypes) {
              var name = getComponentNameFromType(type);
              checkPropTypes(propTypes, element.props, "prop", name, element);
            } else if (type.PropTypes !== void 0 && !propTypesMisspellWarningShown) {
              propTypesMisspellWarningShown = true;
              var _name = getComponentNameFromType(type);
              error("Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?", _name || "Unknown");
            }
            if (typeof type.getDefaultProps === "function" && !type.getDefaultProps.isReactClassApproved) {
              error("getDefaultProps is only used on classic React.createClass definitions. Use a static property named `defaultProps` instead.");
            }
          }
        }
        function validateFragmentProps(fragment) {
          {
            var keys = Object.keys(fragment.props);
            for (var i2 = 0; i2 < keys.length; i2++) {
              var key = keys[i2];
              if (key !== "children" && key !== "key") {
                setCurrentlyValidatingElement$1(fragment);
                error("Invalid prop `%s` supplied to `React.Fragment`. React.Fragment can only have `key` and `children` props.", key);
                setCurrentlyValidatingElement$1(null);
                break;
              }
            }
            if (fragment.ref !== null) {
              setCurrentlyValidatingElement$1(fragment);
              error("Invalid attribute `ref` supplied to `React.Fragment`.");
              setCurrentlyValidatingElement$1(null);
            }
          }
        }
        function jsxWithValidation(type, props, key, isStaticChildren, source, self) {
          {
            var validType = isValidElementType(type);
            if (!validType) {
              var info = "";
              if (type === void 0 || typeof type === "object" && type !== null && Object.keys(type).length === 0) {
                info += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.";
              }
              var sourceInfo = getSourceInfoErrorAddendum(source);
              if (sourceInfo) {
                info += sourceInfo;
              } else {
                info += getDeclarationErrorAddendum();
              }
              var typeString;
              if (type === null) {
                typeString = "null";
              } else if (isArray(type)) {
                typeString = "array";
              } else if (type !== void 0 && type.$$typeof === REACT_ELEMENT_TYPE) {
                typeString = "<" + (getComponentNameFromType(type.type) || "Unknown") + " />";
                info = " Did you accidentally export a JSX literal instead of a component?";
              } else {
                typeString = typeof type;
              }
              error("React.jsx: type is invalid -- expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s", typeString, info);
            }
            var element = jsxDEV(type, props, key, source, self);
            if (element == null) {
              return element;
            }
            if (validType) {
              var children = props.children;
              if (children !== void 0) {
                if (isStaticChildren) {
                  if (isArray(children)) {
                    for (var i2 = 0; i2 < children.length; i2++) {
                      validateChildKeys(children[i2], type);
                    }
                    if (Object.freeze) {
                      Object.freeze(children);
                    }
                  } else {
                    error("React.jsx: Static children should always be an array. You are likely explicitly calling React.jsxs or React.jsxDEV. Use the Babel transform instead.");
                  }
                } else {
                  validateChildKeys(children, type);
                }
              }
            }
            if (type === REACT_FRAGMENT_TYPE) {
              validateFragmentProps(element);
            } else {
              validatePropTypes(element);
            }
            return element;
          }
        }
        function jsxWithValidationStatic(type, props, key) {
          {
            return jsxWithValidation(type, props, key, true);
          }
        }
        function jsxWithValidationDynamic(type, props, key) {
          {
            return jsxWithValidation(type, props, key, false);
          }
        }
        var jsx2 = jsxWithValidationDynamic;
        var jsxs2 = jsxWithValidationStatic;
        exports.Fragment = REACT_FRAGMENT_TYPE;
        exports.jsx = jsx2;
        exports.jsxs = jsxs2;
      })();
    }
  }
});

// node_modules/react/jsx-runtime.js
var require_jsx_runtime = __commonJS({
  "node_modules/react/jsx-runtime.js"(exports, module) {
    "use strict";
    if (false) {
      module.exports = null;
    } else {
      module.exports = require_react_jsx_runtime_development();
    }
  }
});

// node_modules/@react-three/postprocessing/dist/index.js
var import_jsx_runtime = __toESM(require_jsx_runtime());
var import_react = __toESM(require_react());

// node_modules/screen-space-reflections/dist/index.js
function _extends() {
  _extends = Object.assign ? Object.assign.bind() : function(target) {
    for (var i2 = 1; i2 < arguments.length; i2++) {
      var source = arguments[i2];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends.apply(this, arguments);
}
var boxBlur = "#define GLSLIFY 1\nuniform float blur;uniform float blurSharpness;uniform int blurKernel;vec3 denoise(vec3 center,sampler2D tex,vec2 uv,vec2 invTexSize,float blur,float blurSharpness,int blurKernel){vec3 color;float total;vec3 col;float weight;for(int x=-blurKernel;x<=blurKernel;x++){for(int y=-blurKernel;y<=blurKernel;y++){col=textureLod(tex,uv+vec2(x,y)*invTexSize,0.).rgb;weight=1.0-abs(dot(col-center,vec3(0.25)));weight=pow(weight,blurSharpness);color+=col*weight;total+=weight;}}return color/total;}";
var finalSSRShader = "#define GLSLIFY 1\n#define MODE_DEFAULT 0\n#define MODE_REFLECTIONS 1\n#define MODE_RAW_REFLECTION 2\n#define MODE_BLURRED_REFLECTIONS 3\n#define MODE_INPUT 4\n#define MODE_BLUR_MIX 5\n#define FLOAT_EPSILON 0.00001\nuniform sampler2D inputTexture;uniform sampler2D reflectionsTexture;uniform float samples;\n#include <boxBlur>\nvoid mainImage(const in vec4 inputColor,const in vec2 uv,out vec4 outputColor){vec4 reflectionsTexel=texture2D(reflectionsTexture,vUv);ivec2 size=textureSize(reflectionsTexture,0);vec2 invTexSize=1./vec2(size.x,size.y);vec3 reflectionClr=reflectionsTexel.xyz;if(blur>FLOAT_EPSILON){vec3 blurredReflectionsColor=denoise(reflectionsTexel.rgb,reflectionsTexture,vUv,invTexSize,blur,blurSharpness,blurKernel);reflectionClr=mix(reflectionClr,blurredReflectionsColor.rgb,blur);}\n#if RENDER_MODE == MODE_DEFAULT\noutputColor=vec4(inputColor.rgb+reflectionClr,1.0);\n#endif\n#if RENDER_MODE == MODE_REFLECTIONS\noutputColor=vec4(reflectionClr,1.0);\n#endif\n#if RENDER_MODE == MODE_RAW_REFLECTION\noutputColor=vec4(reflectionsTexel.xyz,1.0);\n#endif\n#if RENDER_MODE == MODE_BLURRED_REFLECTIONS\noutputColor=vec4(blurredReflectionsTexel.xyz,1.0);\n#endif\n#if RENDER_MODE == MODE_INPUT\noutputColor=vec4(inputColor.xyz,1.0);\n#endif\n#if RENDER_MODE == MODE_BLUR_MIX\noutputColor=vec4(vec3(blur),1.0);\n#endif\n}";
var helperFunctions = "#define GLSLIFY 1\nvec3 getViewPosition(const float depth){float clipW=_projectionMatrix[2][3]*depth+_projectionMatrix[3][3];vec4 clipPosition=vec4((vec3(vUv,depth)-0.5)*2.0,1.0);clipPosition*=clipW;return(_inverseProjectionMatrix*clipPosition).xyz;}float getViewZ(const in float depth){\n#ifdef PERSPECTIVE_CAMERA\nreturn perspectiveDepthToViewZ(depth,cameraNear,cameraFar);\n#else\nreturn orthographicDepthToViewZ(depth,cameraNear,cameraFar);\n#endif\n}vec3 screenSpaceToWorldSpace(const vec2 uv,const float depth){vec4 ndc=vec4((uv.x-0.5)*2.0,(uv.y-0.5)*2.0,(depth-0.5)*2.0,1.0);vec4 clip=_inverseProjectionMatrix*ndc;vec4 view=cameraMatrixWorld*(clip/clip.w);return view.xyz;}\n#define Scale (vec3(0.8, 0.8, 0.8))\n#define K (19.19)\nvec3 hash(vec3 a){a=fract(a*Scale);a+=dot(a,a.yxz+K);return fract((a.xxy+a.yxx)*a.zyx);}float fresnel_dielectric_cos(float cosi,float eta){float c=abs(cosi);float g=eta*eta-1.0+c*c;float result;if(g>0.0){g=sqrt(g);float A=(g-c)/(g+c);float B=(c*(g+c)-1.0)/(c*(g-c)+1.0);result=0.5*A*A*(1.0+B*B);}else{result=1.0;}return result;}float fresnel_dielectric(vec3 Incoming,vec3 Normal,float eta){float cosine=dot(Incoming,Normal);return min(1.0,5.0*fresnel_dielectric_cos(cosine,eta));}";
var trCompose = "#define GLSLIFY 1\n#define INV_EULER 0.36787944117144233\nalpha=velocityDisocclusion<FLOAT_EPSILON ?(alpha+0.0075): 0.0;alpha=clamp(alpha,0.0,1.0);bool needsBlur=!didReproject||velocityDisocclusion>0.5;\n#ifdef boxBlur\nif(needsBlur)inputColor=boxBlurredColor;\n#endif\nif(alpha==1.0){outputColor=accumulatedColor;}else{float m=mix(alpha,1.0,blend);if(needsBlur)m=0.0;outputColor=accumulatedColor*m+inputColor*(1.0-m);}";
var MRTMaterial = class extends ShaderMaterial {
  constructor() {
    super({
      type: "MRTMaterial",
      defines: {
        USE_UV: "",
        TEMPORAL_RESOLVE: ""
      },
      uniforms: {
        opacity: new Uniform(1),
        normalMap: new Uniform(null),
        normalScale: new Uniform(new Vector2(1, 1)),
        uvTransform: new Uniform(new Matrix3()),
        roughness: new Uniform(1),
        roughnessMap: new Uniform(null)
      },
      vertexShader: (
        /* glsl */
        `
                #ifdef USE_MRT
                 varying vec2 vHighPrecisionZW;
                #endif
                #define NORMAL
                #if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )
                    varying vec3 vViewPosition;
                #endif
                #include <common>
                #include <uv_pars_vertex>
                #include <displacementmap_pars_vertex>
                #include <normal_pars_vertex>
                #include <morphtarget_pars_vertex>
                #include <skinning_pars_vertex>
                #include <logdepthbuf_pars_vertex>
                #include <clipping_planes_pars_vertex>
                void main() {
                    #include <uv_vertex>
                    #include <beginnormal_vertex>
                    #include <morphnormal_vertex>
                    #include <skinbase_vertex>
                    #include <skinnormal_vertex>
                    #include <defaultnormal_vertex>
                    #include <normal_vertex>
                    #include <begin_vertex>
                    #include <morphtarget_vertex>
                    #include <skinning_vertex>
                    #include <displacementmap_vertex>
                    #include <project_vertex>
                    #include <logdepthbuf_vertex>
                    #include <clipping_planes_vertex>
                    #if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )
                        vViewPosition = - mvPosition.xyz;
                    #endif
                    #ifdef USE_MRT
                        vHighPrecisionZW = gl_Position.zw;
                    #endif 
                    #ifdef USE_UV
                        vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
                    #endif
                }
            `
      ),
      fragmentShader: (
        /* glsl */
        `
                 #define NORMAL
                #if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )
                    varying vec3 vViewPosition;
                #endif
                #include <packing>
                #include <uv_pars_fragment>
                #include <normal_pars_fragment>
                #include <bumpmap_pars_fragment>
                #include <normalmap_pars_fragment>
                #include <logdepthbuf_pars_fragment>
                #include <clipping_planes_pars_fragment>
                #include <roughnessmap_pars_fragment>
                
                #ifdef USE_MRT
                layout(location = 0) out vec4 gNormal;
                layout(location = 1) out vec4 gDepth;
                
                varying vec2 vHighPrecisionZW;
                #endif
                uniform float roughness;
                void main() {
                    #include <clipping_planes_fragment>
                    #include <logdepthbuf_fragment>
                    #include <normal_fragment_begin>
                    #include <normal_fragment_maps>

                    float roughnessFactor = roughness;
                    
                    if(roughness > 10.0e9){
                        roughnessFactor = 1.;
                    }else{
                        #ifdef useRoughnessMap
                            vec4 texelRoughness = texture2D( roughnessMap, vUv );
                            // reads channel G, compatible with a combined OcclusionRoughnessMetallic (RGB) texture
                            roughnessFactor *= texelRoughness.g;
                        #endif
                    }

                    vec3 normalColor = packNormalToRGB( normal );
                    #ifdef USE_MRT
                        float fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;
                        vec4 depthColor = packDepthToRGBA( fragCoordZ );
                        gNormal = vec4( normalColor, roughnessFactor );
                        gDepth = depthColor;
                    #else
                        gl_FragColor = vec4(normalColor, roughnessFactor);
                    #endif
                }
            `
      ),
      toneMapped: false
    });
    this.normalMapType = TangentSpaceNormalMap;
    this.normalScale = new Vector2(1, 1);
    Object.defineProperty(this, "glslVersion", {
      get() {
        return "USE_MRT" in this.defines ? GLSL3 : null;
      },
      set(_) {
      }
    });
  }
};
var vertexShader$1 = "#define GLSLIFY 1\nvarying vec2 vUv;void main(){vUv=position.xy*0.5+0.5;gl_Position=vec4(position.xy,1.0,1.0);}";
var fragmentShader = "#define GLSLIFY 1\nvarying vec2 vUv;uniform sampler2D inputTexture;uniform sampler2D accumulatedTexture;uniform sampler2D normalTexture;uniform sampler2D depthTexture;uniform sampler2D envMap;uniform mat4 _projectionMatrix;uniform mat4 _inverseProjectionMatrix;uniform mat4 cameraMatrixWorld;uniform float cameraNear;uniform float cameraFar;uniform float rayDistance;uniform float intensity;uniform float maxDepthDifference;uniform float roughnessFade;uniform float maxRoughness;uniform float fade;uniform float thickness;uniform float ior;uniform float samples;uniform float jitter;uniform float jitterRoughness;\n#define INVALID_RAY_COORDS vec2(-1.0);\n#define EARLY_OUT_COLOR vec4(0.0, 0.0, 0.0, 1.0)\n#define FLOAT_EPSILON 0.00001\nfloat nearMinusFar;float nearMulFar;float farMinusNear;\n#include <packing>\n#include <helperFunctions>\nvec2 RayMarch(vec3 dir,inout vec3 hitPos,inout float rayHitDepthDifference);vec2 BinarySearch(in vec3 dir,inout vec3 hitPos,inout float rayHitDepthDifference);float fastGetViewZ(const in float depth);vec3 getIBLRadiance(const in vec3 viewDir,const in vec3 normal,const in float roughness);void main(){vec4 depthTexel=textureLod(depthTexture,vUv,0.0);if(dot(depthTexel.rgb,depthTexel.rgb)<FLOAT_EPSILON){gl_FragColor=EARLY_OUT_COLOR;return;}float unpackedDepth=unpackRGBAToDepth(depthTexel);vec4 normalTexel=textureLod(normalTexture,vUv,0.0);float roughness=normalTexel.a;float specular=1.0-roughness;nearMinusFar=cameraNear-cameraFar;nearMulFar=cameraNear*cameraFar;farMinusNear=cameraFar-cameraNear;normalTexel.rgb=unpackRGBToNormal(normalTexel.rgb);float depth=fastGetViewZ(unpackedDepth);vec3 viewPos=getViewPosition(depth);vec3 viewDir=normalize(viewPos);vec3 viewNormal=normalTexel.xyz;vec3 worldPos=screenSpaceToWorldSpace(vUv,unpackedDepth);vec3 jitt=vec3(0.0);if(jitterRoughness!=0.0||jitter!=0.0){vec3 randomJitter=hash(50.0*samples*worldPos)-0.5;float spread=((2.0-specular)+roughness*jitterRoughness);float jitterMix=jitter*0.25+jitterRoughness*roughness;if(jitterMix>1.0)jitterMix=1.0;jitt=mix(vec3(0.0),randomJitter*spread,jitterMix);}viewNormal+=jitt;float fresnelFactor=fresnel_dielectric(viewDir,viewNormal,ior);vec3 iblRadiance=getIBLRadiance(-viewDir,viewNormal,0.)*fresnelFactor;float lastFrameAlpha=textureLod(accumulatedTexture,vUv,0.0).a;if(roughness>maxRoughness||(roughness>1.0-FLOAT_EPSILON&&roughnessFade>1.0-FLOAT_EPSILON)){gl_FragColor=vec4(iblRadiance,lastFrameAlpha);return;}vec3 reflected=reflect(viewDir,viewNormal);vec3 rayDir=reflected*-viewPos.z;vec3 hitPos=viewPos;float rayHitDepthDifference;vec2 coords=RayMarch(rayDir,hitPos,rayHitDepthDifference);if(coords.x==-1.0){gl_FragColor=vec4(iblRadiance,lastFrameAlpha);return;}vec4 SSRTexel=textureLod(inputTexture,coords.xy,0.0);vec4 SSRTexelReflected=textureLod(accumulatedTexture,coords.xy,0.0);vec3 SSR=SSRTexel.rgb+SSRTexelReflected.rgb;float roughnessFactor=mix(specular,1.0,max(0.0,1.0-roughnessFade));vec2 coordsNDC=(coords.xy*2.0-1.0);float screenFade=0.1;float maxDimension=min(1.0,max(abs(coordsNDC.x),abs(coordsNDC.y)));float reflectionIntensity=1.0-(max(0.0,maxDimension-screenFade)/(1.0-screenFade));reflectionIntensity=max(0.,reflectionIntensity);vec3 finalSSR=mix(iblRadiance,SSR,reflectionIntensity)*roughnessFactor;if(fade!=0.0){vec3 hitWorldPos=screenSpaceToWorldSpace(coords,rayHitDepthDifference);float reflectionDistance=distance(hitWorldPos,worldPos)+1.0;float opacity=1.0/(reflectionDistance*fade*0.1);if(opacity>1.0)opacity=1.0;finalSSR*=opacity;}finalSSR*=fresnelFactor*intensity;finalSSR=min(vec3(1.0),finalSSR);float alpha=hitPos.z==1.0 ? 1.0 : SSRTexelReflected.a;alpha=min(lastFrameAlpha,alpha);gl_FragColor=vec4(finalSSR,alpha);}vec2 RayMarch(vec3 dir,inout vec3 hitPos,inout float rayHitDepthDifference){dir=normalize(dir);dir*=rayDistance/float(steps);float depth;vec4 projectedCoord;vec4 lastProjectedCoord;float unpackedDepth;vec4 depthTexel;for(int i=0;i<steps;i++){hitPos+=dir;projectedCoord=_projectionMatrix*vec4(hitPos,1.0);projectedCoord.xy/=projectedCoord.w;projectedCoord.xy=projectedCoord.xy*0.5+0.5;\n#ifndef missedRays\nif(projectedCoord.x<0.0||projectedCoord.x>1.0||projectedCoord.y<0.0||projectedCoord.y>1.0){return INVALID_RAY_COORDS;}\n#endif\ndepthTexel=textureLod(depthTexture,projectedCoord.xy,0.0);unpackedDepth=unpackRGBAToDepth(depthTexel);depth=fastGetViewZ(unpackedDepth);rayHitDepthDifference=depth-hitPos.z;if(rayHitDepthDifference>=0.0&&rayHitDepthDifference<thickness){\n#if refineSteps == 0\nif(dot(depthTexel.rgb,depthTexel.rgb)<FLOAT_EPSILON)return INVALID_RAY_COORDS;\n#else\nreturn BinarySearch(dir,hitPos,rayHitDepthDifference);\n#endif\n}\n#ifndef missedRays\nif(hitPos.z>0.0){return INVALID_RAY_COORDS;}\n#endif\nlastProjectedCoord=projectedCoord;}hitPos.z=1.0;\n#ifndef missedRays\nreturn INVALID_RAY_COORDS;\n#endif\nrayHitDepthDifference=unpackedDepth;return projectedCoord.xy;}vec2 BinarySearch(in vec3 dir,inout vec3 hitPos,inout float rayHitDepthDifference){float depth;vec4 projectedCoord;vec2 lastMinProjectedCoordXY;float unpackedDepth;vec4 depthTexel;for(int i=0;i<refineSteps;i++){projectedCoord=_projectionMatrix*vec4(hitPos,1.0);projectedCoord.xy/=projectedCoord.w;projectedCoord.xy=projectedCoord.xy*0.5+0.5;depthTexel=textureLod(depthTexture,projectedCoord.xy,0.0);unpackedDepth=unpackRGBAToDepth(depthTexel);depth=fastGetViewZ(unpackedDepth);rayHitDepthDifference=depth-hitPos.z;dir*=0.5;if(rayHitDepthDifference>0.0){hitPos-=dir;}else{hitPos+=dir;}}if(dot(depthTexel.rgb,depthTexel.rgb)<FLOAT_EPSILON)return INVALID_RAY_COORDS;if(abs(rayHitDepthDifference)>maxDepthDifference)return INVALID_RAY_COORDS;projectedCoord=_projectionMatrix*vec4(hitPos,1.0);projectedCoord.xy/=projectedCoord.w;projectedCoord.xy=projectedCoord.xy*0.5+0.5;rayHitDepthDifference=unpackedDepth;return projectedCoord.xy;}float fastGetViewZ(const in float depth){\n#ifdef PERSPECTIVE_CAMERA\nreturn nearMulFar/(farMinusNear*depth-cameraFar);\n#else\nreturn depth*nearMinusFar-cameraNear;\n#endif\n}\n#include <common>\n#include <cube_uv_reflection_fragment>\nvec3 getIBLRadiance(const in vec3 viewDir,const in vec3 normal,const in float roughness){\n#if defined(ENVMAP_TYPE_CUBE_UV)\nvec3 reflectVec=reflect(-viewDir,normal);reflectVec=normalize(mix(reflectVec,normal,roughness*roughness));reflectVec=inverseTransformDirection(reflectVec,viewMatrix);vec4 envMapColor=textureCubeUV(envMap,reflectVec,roughness);return envMapColor.rgb*intensity;\n#else\nreturn vec3(0.0);\n#endif\n}";
var ReflectionsMaterial = class extends ShaderMaterial {
  constructor() {
    super({
      type: "ReflectionsMaterial",
      uniforms: {
        inputTexture: new Uniform(null),
        accumulatedTexture: new Uniform(null),
        normalTexture: new Uniform(null),
        depthTexture: new Uniform(null),
        _projectionMatrix: new Uniform(new Matrix4()),
        _inverseProjectionMatrix: new Uniform(new Matrix4()),
        cameraMatrixWorld: new Uniform(new Matrix4()),
        cameraNear: new Uniform(0),
        cameraFar: new Uniform(0),
        rayDistance: new Uniform(0),
        intensity: new Uniform(0),
        roughnessFade: new Uniform(0),
        fade: new Uniform(0),
        thickness: new Uniform(0),
        ior: new Uniform(0),
        maxDepthDifference: new Uniform(0),
        jitter: new Uniform(0),
        jitterRoughness: new Uniform(0),
        maxRoughness: new Uniform(0),
        samples: new Uniform(0),
        envMap: new Uniform(null),
        envMapPosition: new Uniform(new Vector3()),
        envMapSize: new Uniform(new Vector3()),
        viewMatrix: new Uniform(new Matrix4())
      },
      defines: {
        steps: 20,
        refineSteps: 5,
        CUBEUV_TEXEL_WIDTH: 0,
        CUBEUV_TEXEL_HEIGHT: 0,
        CUBEUV_MAX_MIP: 0,
        vWorldPosition: "worldPos"
      },
      fragmentShader: fragmentShader.replace("#include <helperFunctions>", helperFunctions),
      vertexShader: vertexShader$1,
      toneMapped: false,
      depthWrite: false,
      depthTest: false
    });
  }
};
var getVisibleChildren = (object) => {
  const queue = [object];
  const objects = [];
  while (queue.length !== 0) {
    const mesh = queue.shift();
    if (mesh.material)
      objects.push(mesh);
    for (const c of mesh.children) {
      if (c.visible)
        queue.push(c);
    }
  }
  return objects;
};
var generateCubeUVSize = (parameters) => {
  const imageHeight = parameters.envMapCubeUVHeight;
  if (imageHeight === null)
    return null;
  const maxMip = Math.log2(imageHeight) - 2;
  const texelHeight = 1 / imageHeight;
  const texelWidth = 1 / (3 * Math.max(Math.pow(2, maxMip), 7 * 16));
  return {
    texelWidth,
    texelHeight,
    maxMip
  };
};
var setupEnvMap = (reflectionsMaterial, envMap, envMapCubeUVHeight) => {
  reflectionsMaterial.uniforms.envMap.value = envMap;
  const envMapCubeUVSize = generateCubeUVSize({
    envMapCubeUVHeight
  });
  reflectionsMaterial.defines.ENVMAP_TYPE_CUBE_UV = "";
  reflectionsMaterial.defines.CUBEUV_TEXEL_WIDTH = envMapCubeUVSize.texelWidth;
  reflectionsMaterial.defines.CUBEUV_TEXEL_HEIGHT = envMapCubeUVSize.texelHeight;
  reflectionsMaterial.defines.CUBEUV_MAX_MIP = envMapCubeUVSize.maxMip + ".0";
  reflectionsMaterial.needsUpdate = true;
};
var isWebGL2Available2 = () => {
  try {
    const canvas = document.createElement("canvas");
    return !!(window.WebGL2RenderingContext && canvas.getContext("webgl2"));
  } catch (e) {
    return false;
  }
};
var ReflectionsPass = class extends Pass {
  constructor(ssrEffect, options = {}) {
    super("ReflectionsPass");
    this.ssrEffect = void 0;
    this.cachedMaterials = /* @__PURE__ */ new WeakMap();
    this.USE_MRT = false;
    this.webgl1DepthPass = null;
    this.visibleMeshes = [];
    this.ssrEffect = ssrEffect;
    this._scene = ssrEffect._scene;
    this._camera = ssrEffect._camera;
    this.fullscreenMaterial = new ReflectionsMaterial();
    if (ssrEffect._camera.isPerspectiveCamera)
      this.fullscreenMaterial.defines.PERSPECTIVE_CAMERA = "";
    const width = options.width || typeof window !== "undefined" ? window.innerWidth : 2e3;
    const height = options.height || typeof window !== "undefined" ? window.innerHeight : 1e3;
    this.renderTarget = new WebGLRenderTarget(width, height, {
      minFilter: LinearFilter,
      magFilter: LinearFilter,
      type: HalfFloatType,
      depthBuffer: false
    });
    this.renderPass = new RenderPass(this._scene, this._camera);
    this.USE_MRT = isWebGL2Available2();
    if (this.USE_MRT) {
      this.gBuffersRenderTarget = new WebGLMultipleRenderTargets(width, height, 2, {
        minFilter: LinearFilter,
        magFilter: LinearFilter
      });
      this.normalTexture = this.gBuffersRenderTarget.texture[0];
      this.depthTexture = this.gBuffersRenderTarget.texture[1];
    } else {
      this.webgl1DepthPass = new DepthPass(this._scene, this._camera);
      this.webgl1DepthPass.renderTarget.minFilter = LinearFilter;
      this.webgl1DepthPass.renderTarget.magFilter = LinearFilter;
      this.webgl1DepthPass.renderTarget.texture.minFilter = LinearFilter;
      this.webgl1DepthPass.renderTarget.texture.magFilter = LinearFilter;
      this.webgl1DepthPass.setSize(typeof window !== "undefined" ? window.innerWidth : 2e3, typeof window !== "undefined" ? window.innerHeight : 1e3);
      this.gBuffersRenderTarget = new WebGLRenderTarget(width, height, {
        minFilter: LinearFilter,
        magFilter: LinearFilter
      });
      this.normalTexture = this.gBuffersRenderTarget.texture;
      this.depthTexture = this.webgl1DepthPass.texture;
    }
    this.fullscreenMaterial.uniforms.normalTexture.value = this.normalTexture;
    this.fullscreenMaterial.uniforms.depthTexture.value = this.depthTexture;
    this.fullscreenMaterial.uniforms.accumulatedTexture.value = this.ssrEffect.temporalResolvePass.accumulatedTexture;
    this.fullscreenMaterial.uniforms.cameraMatrixWorld.value = this._camera.matrixWorld;
    this.fullscreenMaterial.uniforms._projectionMatrix.value = this._camera.projectionMatrix;
    this.fullscreenMaterial.uniforms._inverseProjectionMatrix.value = this._camera.projectionMatrixInverse;
  }
  setSize(width, height) {
    this.renderTarget.setSize(width * this.ssrEffect.resolutionScale, height * this.ssrEffect.resolutionScale);
    this.gBuffersRenderTarget.setSize(width * this.ssrEffect.resolutionScale, height * this.ssrEffect.resolutionScale);
    this.fullscreenMaterial.uniforms.accumulatedTexture.value = this.ssrEffect.temporalResolvePass.accumulatedTexture;
    this.fullscreenMaterial.needsUpdate = true;
  }
  dispose() {
    this.renderTarget.dispose();
    this.gBuffersRenderTarget.dispose();
    this.renderPass.dispose();
    if (!this.USE_MRT)
      this.webgl1DepthPass.dispose();
    this.fullscreenMaterial.dispose();
    this.normalTexture = null;
    this.depthTexture = null;
    this.velocityTexture = null;
  }
  keepMaterialMapUpdated(mrtMaterial, originalMaterial, prop, define) {
    if (this.ssrEffect[define]) {
      if (originalMaterial[prop] !== mrtMaterial[prop]) {
        mrtMaterial[prop] = originalMaterial[prop];
        mrtMaterial.uniforms[prop].value = originalMaterial[prop];
        if (originalMaterial[prop]) {
          mrtMaterial.defines[define] = "";
        } else {
          delete mrtMaterial.defines[define];
        }
        mrtMaterial.needsUpdate = true;
      }
    } else if (mrtMaterial[prop] !== void 0) {
      mrtMaterial[prop] = void 0;
      mrtMaterial.uniforms[prop].value = void 0;
      delete mrtMaterial.defines[define];
      mrtMaterial.needsUpdate = true;
    }
  }
  setMRTMaterialInScene() {
    this.visibleMeshes = getVisibleChildren(this._scene);
    for (const c of this.visibleMeshes) {
      if (c.material) {
        const originalMaterial = c.material;
        let [cachedOriginalMaterial, mrtMaterial] = this.cachedMaterials.get(c) || [];
        if (originalMaterial !== cachedOriginalMaterial) {
          if (mrtMaterial)
            mrtMaterial.dispose();
          mrtMaterial = new MRTMaterial();
          if (this.USE_MRT)
            mrtMaterial.defines.USE_MRT = "";
          mrtMaterial.normalScale = originalMaterial.normalScale;
          mrtMaterial.uniforms.normalScale.value = originalMaterial.normalScale;
          const map = originalMaterial.map || originalMaterial.normalMap || originalMaterial.roughnessMap || originalMaterial.metalnessMap;
          if (map)
            mrtMaterial.uniforms.uvTransform.value = map.matrix;
          this.cachedMaterials.set(c, [originalMaterial, mrtMaterial]);
        }
        this.keepMaterialMapUpdated(mrtMaterial, originalMaterial, "normalMap", "useNormalMap");
        this.keepMaterialMapUpdated(mrtMaterial, originalMaterial, "roughnessMap", "useRoughnessMap");
        mrtMaterial.uniforms.roughness.value = this.ssrEffect.selection.size === 0 || this.ssrEffect.selection.has(c) ? originalMaterial.roughness || 0 : 1e11;
        c.material = mrtMaterial;
      }
    }
  }
  unsetMRTMaterialInScene() {
    for (const c of this.visibleMeshes) {
      var _c$material;
      if (((_c$material = c.material) == null ? void 0 : _c$material.type) === "MRTMaterial") {
        c.visible = true;
        const [originalMaterial] = this.cachedMaterials.get(c);
        c.material = originalMaterial;
      }
    }
  }
  render(renderer, inputBuffer) {
    this.setMRTMaterialInScene();
    renderer.setRenderTarget(this.gBuffersRenderTarget);
    this.renderPass.render(renderer, this.gBuffersRenderTarget);
    this.unsetMRTMaterialInScene();
    if (!this.USE_MRT)
      this.webgl1DepthPass.renderPass.render(renderer, this.webgl1DepthPass.renderTarget);
    this.fullscreenMaterial.uniforms.inputTexture.value = inputBuffer.texture;
    this.fullscreenMaterial.uniforms.samples.value = this.ssrEffect.temporalResolvePass.samples;
    this.fullscreenMaterial.uniforms.cameraNear.value = this._camera.near;
    this.fullscreenMaterial.uniforms.cameraFar.value = this._camera.far;
    this.fullscreenMaterial.uniforms.viewMatrix.value.copy(this._camera.matrixWorldInverse);
    renderer.setRenderTarget(this.renderTarget);
    renderer.render(this.scene, this.camera);
  }
};
var defaultSSROptions = {
  intensity: 1,
  exponent: 1,
  distance: 10,
  fade: 0,
  roughnessFade: 1,
  thickness: 10,
  ior: 1.45,
  maxRoughness: 1,
  maxDepthDifference: 10,
  blend: 0.9,
  correction: 1,
  correctionRadius: 1,
  blur: 0.5,
  blurKernel: 1,
  blurSharpness: 10,
  jitter: 0,
  jitterRoughness: 0,
  steps: 20,
  refineSteps: 5,
  missedRays: true,
  useNormalMap: true,
  useRoughnessMap: true,
  resolutionScale: 1,
  velocityResolutionScale: 1
};
var vertexShader = "#define GLSLIFY 1\nvarying vec2 vUv;void main(){vUv=position.xy*0.5+0.5;gl_Position=vec4(position.xy,1.0,1.0);}";
var temporalResolve = "#define GLSLIFY 1\nuniform sampler2D inputTexture;uniform sampler2D accumulatedTexture;uniform sampler2D velocityTexture;uniform sampler2D lastVelocityTexture;uniform float blend;uniform float correction;uniform float exponent;uniform float samples;uniform vec2 invTexSize;uniform mat4 curInverseProjectionMatrix;uniform mat4 curCameraMatrixWorld;uniform mat4 prevInverseProjectionMatrix;uniform mat4 prevCameraMatrixWorld;varying vec2 vUv;\n#define MAX_NEIGHBOR_DEPTH_DIFFERENCE 0.001\n#define FLOAT_EPSILON 0.00001\n#define FLOAT_ONE_MINUS_EPSILON 0.99999\nvec3 transformexponent;vec3 undoColorTransformExponent;vec3 transformColor(vec3 color){if(exponent==1.0)return color;return pow(abs(color),transformexponent);}vec3 undoColorTransform(vec3 color){if(exponent==1.0)return color;return max(pow(abs(color),undoColorTransformExponent),vec3(0.0));}void main(){if(exponent!=1.0){transformexponent=vec3(1.0/exponent);undoColorTransformExponent=vec3(exponent);}vec4 inputTexel=textureLod(inputTexture,vUv,0.0);vec4 accumulatedTexel;vec3 inputColor=transformColor(inputTexel.rgb);vec3 accumulatedColor;float alpha=inputTexel.a;float velocityDisocclusion;bool didReproject=false;\n#ifdef boxBlur\nvec3 boxBlurredColor=inputTexel.rgb;\n#endif\nvec4 velocity=textureLod(velocityTexture,vUv,0.0);bool isMoving=alpha<1.0||dot(velocity.xy,velocity.xy)>0.0;if(isMoving){vec3 minNeighborColor=inputColor;vec3 maxNeighborColor=inputColor;vec3 col;vec2 neighborUv;vec2 reprojectedUv=vUv-velocity.xy;vec4 lastVelocity=textureLod(lastVelocityTexture,reprojectedUv,0.0);float depth=velocity.b;float closestDepth=depth;float lastClosestDepth=lastVelocity.b;float neighborDepth;float lastNeighborDepth;for(int x=-correctionRadius;x<=correctionRadius;x++){for(int y=-correctionRadius;y<=correctionRadius;y++){if(x!=0||y!=0){neighborUv=vUv+vec2(x,y)*invTexSize;vec4 neigborVelocity=textureLod(velocityTexture,neighborUv,0.0);neighborDepth=neigborVelocity.b;col=textureLod(inputTexture,neighborUv,0.0).xyz;int absX=abs(x);int absY=abs(y);\n#ifdef dilation\nif(absX==1&&absY==1){if(neighborDepth>closestDepth){velocity=neigborVelocity;closestDepth=neighborDepth;}vec4 lastNeighborVelocity=textureLod(velocityTexture,vUv+vec2(x,y)*invTexSize,0.0);lastNeighborDepth=lastNeighborVelocity.b;if(neighborDepth>closestDepth){lastVelocity=lastNeighborVelocity;lastClosestDepth=lastNeighborDepth;}}\n#endif\nif(abs(depth-neighborDepth)<MAX_NEIGHBOR_DEPTH_DIFFERENCE){\n#ifdef boxBlur\nif(absX<=2&&absY<=2)boxBlurredColor+=col;\n#endif\ncol=transformColor(col);minNeighborColor=min(col,minNeighborColor);maxNeighborColor=max(col,maxNeighborColor);}}}}float velocityLength=length(lastVelocity.xy-velocity.xy);velocityDisocclusion=(velocityLength-0.000005)*10.0;velocityDisocclusion*=velocityDisocclusion;reprojectedUv=vUv-velocity.xy;\n#ifdef boxBlur\nfloat pxRadius=correctionRadius>5 ? 121.0 : pow(float(correctionRadius*2+1),2.0);boxBlurredColor/=pxRadius;boxBlurredColor=transformColor(boxBlurredColor);\n#endif\nif(reprojectedUv.x>=0.0&&reprojectedUv.x<=1.0&&reprojectedUv.y>=0.0&&reprojectedUv.y<=1.0){accumulatedTexel=textureLod(accumulatedTexture,reprojectedUv,0.0);accumulatedColor=transformColor(accumulatedTexel.rgb);vec3 clampedColor=clamp(accumulatedColor,minNeighborColor,maxNeighborColor);accumulatedColor=mix(accumulatedColor,clampedColor,correction);didReproject=true;}else{\n#ifdef boxBlur\naccumulatedColor=boxBlurredColor;\n#else\naccumulatedColor=inputColor;\n#endif\n}if(velocity.r>FLOAT_ONE_MINUS_EPSILON&&velocity.g>FLOAT_ONE_MINUS_EPSILON){alpha=0.0;velocityDisocclusion=1.0;}}else{accumulatedColor=transformColor(textureLod(accumulatedTexture,vUv,0.0).rgb);}vec3 outputColor=inputColor;\n#include <custom_compose_shader>\ngl_FragColor=vec4(undoColorTransform(outputColor),alpha);}";
var TemporalResolveMaterial = class extends ShaderMaterial {
  constructor(customComposeShader) {
    const fragmentShader2 = temporalResolve.replace("#include <custom_compose_shader>", customComposeShader);
    super({
      type: "TemporalResolveMaterial",
      uniforms: {
        inputTexture: new Uniform(null),
        accumulatedTexture: new Uniform(null),
        velocityTexture: new Uniform(null),
        lastVelocityTexture: new Uniform(null),
        samples: new Uniform(1),
        blend: new Uniform(0.5),
        correction: new Uniform(1),
        exponent: new Uniform(1),
        invTexSize: new Uniform(new Vector2())
      },
      defines: {
        correctionRadius: 1
      },
      vertexShader,
      fragmentShader: fragmentShader2
    });
  }
};
var prev_skinning_pars_vertex = (
  /* glsl */
  `
		#ifdef USE_SKINNING
		#ifdef BONE_TEXTURE
			uniform sampler2D prevBoneTexture;
			mat4 getPrevBoneMatrix( const in float i ) {
				float j = i * 4.0;
				float x = mod( j, float( boneTextureSize ) );
				float y = floor( j / float( boneTextureSize ) );
				float dx = 1.0 / float( boneTextureSize );
				float dy = 1.0 / float( boneTextureSize );
				y = dy * ( y + 0.5 );
				vec4 v1 = texture2D( prevBoneTexture, vec2( dx * ( x + 0.5 ), y ) );
				vec4 v2 = texture2D( prevBoneTexture, vec2( dx * ( x + 1.5 ), y ) );
				vec4 v3 = texture2D( prevBoneTexture, vec2( dx * ( x + 2.5 ), y ) );
				vec4 v4 = texture2D( prevBoneTexture, vec2( dx * ( x + 3.5 ), y ) );
				mat4 bone = mat4( v1, v2, v3, v4 );
				return bone;
			}
		#else
			uniform mat4 prevBoneMatrices[ MAX_BONES ];
			mat4 getPrevBoneMatrix( const in float i ) {
				mat4 bone = prevBoneMatrices[ int(i) ];
				return bone;
			}
		#endif
		#endif
`
);
var velocity_vertex = (
  /* glsl */
  `
		vec3 transformed;

		// Get the normal
		${ShaderChunk.skinbase_vertex}
		${ShaderChunk.beginnormal_vertex}
		${ShaderChunk.skinnormal_vertex}
		${ShaderChunk.defaultnormal_vertex}

		// Get the current vertex position
		transformed = vec3( position );
		${ShaderChunk.skinning_vertex}
		newPosition = velocityMatrix * vec4( transformed, 1.0 );

		// Get the previous vertex position
		transformed = vec3( position );
		${ShaderChunk.skinbase_vertex.replace(/mat4 /g, "").replace(/getBoneMatrix/g, "getPrevBoneMatrix")}
		${ShaderChunk.skinning_vertex.replace(/vec4 /g, "")}
		prevPosition = prevVelocityMatrix * vec4( transformed, 1.0 );

		gl_Position = newPosition;
`
);
var VelocityMaterial = class extends ShaderMaterial {
  constructor() {
    super({
      uniforms: {
        prevVelocityMatrix: {
          value: new Matrix4()
        },
        velocityMatrix: {
          value: new Matrix4()
        },
        prevBoneTexture: {
          value: null
        },
        interpolateGeometry: {
          value: 0
        },
        intensity: {
          value: 1
        },
        boneTexture: {
          value: null
        },
        alphaTest: {
          value: 0
        },
        map: {
          value: null
        },
        alphaMap: {
          value: null
        },
        opacity: {
          value: 1
        }
      },
      vertexShader: (
        /* glsl */
        `
                    #define MAX_BONES 1024
                    
                    ${ShaderChunk.skinning_pars_vertex}
                    ${prev_skinning_pars_vertex}
        
                    uniform mat4 velocityMatrix;
                    uniform mat4 prevVelocityMatrix;
                    uniform float interpolateGeometry;
                    varying vec4 prevPosition;
                    varying vec4 newPosition;
					varying vec2 vHighPrecisionZW;
        
                    void main() {
        
                        ${velocity_vertex}

						vHighPrecisionZW = gl_Position.zw;
        
                    }`
      ),
      fragmentShader: (
        /* glsl */
        `
                    uniform float intensity;
                    varying vec4 prevPosition;
                    varying vec4 newPosition;
					varying vec2 vHighPrecisionZW;
        
                    void main() {
						#ifdef FULL_MOVEMENT
						gl_FragColor = vec4( 1., 1., 1. - gl_FragCoord.z, 0. );
						return;
						#endif

                        vec2 pos0 = (prevPosition.xy / prevPosition.w) * 0.5 + 0.5;
                        vec2 pos1 = (newPosition.xy / newPosition.w) * 0.5 + 0.5;
        
                        vec2 vel = pos1 - pos0;

						float fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;
                        
                        gl_FragColor = vec4( vel, 1. - fragCoordZ, 0. );
        
                    }`
      )
    });
    this.isVelocityMaterial = true;
  }
};
var backgroundColor = new Color(0);
var updateProperties = ["visible", "wireframe", "side"];
var VelocityPass = class extends Pass {
  constructor(scene, camera) {
    var _window, _window2;
    super("VelocityPass");
    this.cachedMaterials = /* @__PURE__ */ new WeakMap();
    this.lastCameraTransform = {
      position: new Vector3(),
      quaternion: new Quaternion()
    };
    this.visibleMeshes = [];
    this.renderedMeshesThisFrame = 0;
    this.renderedMeshesLastFrame = 0;
    this._scene = scene;
    this._camera = camera;
    this.renderTarget = new WebGLRenderTarget(((_window = window) == null ? void 0 : _window.innerWidth) || 1e3, ((_window2 = window) == null ? void 0 : _window2.innerHeight) || 1e3, {
      type: HalfFloatType
    });
  }
  setVelocityMaterialInScene() {
    this.renderedMeshesThisFrame = 0;
    this.visibleMeshes = getVisibleChildren(this._scene);
    for (const c of this.visibleMeshes) {
      var _c$skeleton2;
      const originalMaterial = c.material;
      let [cachedOriginalMaterial, velocityMaterial] = this.cachedMaterials.get(c) || [];
      if (originalMaterial !== cachedOriginalMaterial) {
        var _c$skeleton;
        velocityMaterial = new VelocityMaterial();
        velocityMaterial.lastMatrixWorld = new Matrix4();
        c.material = velocityMaterial;
        if ((_c$skeleton = c.skeleton) != null && _c$skeleton.boneTexture)
          this.saveBoneTexture(c);
        this.cachedMaterials.set(c, [originalMaterial, velocityMaterial]);
      }
      velocityMaterial.uniforms.velocityMatrix.value.multiplyMatrices(this._camera.projectionMatrix, c.modelViewMatrix);
      if (c.userData.needsUpdatedReflections || originalMaterial.map instanceof VideoTexture) {
        if (!("FULL_MOVEMENT" in velocityMaterial.defines))
          velocityMaterial.needsUpdate = true;
        velocityMaterial.defines.FULL_MOVEMENT = "";
      } else {
        if ("FULL_MOVEMENT" in velocityMaterial.defines) {
          delete velocityMaterial.defines.FULL_MOVEMENT;
          velocityMaterial.needsUpdate = true;
        }
      }
      c.visible = this.cameraMovedThisFrame || !c.matrixWorld.equals(velocityMaterial.lastMatrixWorld) || c.skeleton || "FULL_MOVEMENT" in velocityMaterial.defines;
      c.material = velocityMaterial;
      if (!c.visible)
        continue;
      this.renderedMeshesThisFrame++;
      for (const prop of updateProperties)
        velocityMaterial[prop] = originalMaterial[prop];
      if ((_c$skeleton2 = c.skeleton) != null && _c$skeleton2.boneTexture) {
        velocityMaterial.defines.USE_SKINNING = "";
        velocityMaterial.defines.BONE_TEXTURE = "";
        velocityMaterial.uniforms.boneTexture.value = c.skeleton.boneTexture;
      }
    }
  }
  saveBoneTexture(object) {
    let boneTexture = object.material.uniforms.prevBoneTexture.value;
    if (boneTexture && boneTexture.image.width === object.skeleton.boneTexture.width) {
      boneTexture = object.material.uniforms.prevBoneTexture.value;
      boneTexture.image.data.set(object.skeleton.boneTexture.image.data);
    } else {
      var _boneTexture;
      (_boneTexture = boneTexture) == null ? void 0 : _boneTexture.dispose();
      const boneMatrices = object.skeleton.boneTexture.image.data.slice();
      const size = object.skeleton.boneTexture.image.width;
      boneTexture = new DataTexture(boneMatrices, size, size, RGBAFormat, FloatType);
      object.material.uniforms.prevBoneTexture.value = boneTexture;
      boneTexture.needsUpdate = true;
    }
  }
  unsetVelocityMaterialInScene() {
    for (const c of this.visibleMeshes) {
      if (c.material.isVelocityMaterial) {
        var _c$skeleton3;
        c.visible = true;
        c.material.lastMatrixWorld.copy(c.matrixWorld);
        c.material.uniforms.prevVelocityMatrix.value.multiplyMatrices(this._camera.projectionMatrix, c.modelViewMatrix);
        if ((_c$skeleton3 = c.skeleton) != null && _c$skeleton3.boneTexture)
          this.saveBoneTexture(c);
        c.material = this.cachedMaterials.get(c)[0];
      }
    }
  }
  setSize(width, height) {
    this.renderTarget.setSize(width, height);
  }
  renderVelocity(renderer) {
    renderer.setRenderTarget(this.renderTarget);
    if (this.renderedMeshesThisFrame > 0) {
      const {
        background
      } = this._scene;
      this._scene.background = backgroundColor;
      renderer.render(this._scene, this._camera);
      this._scene.background = background;
    } else {
      renderer.clearColor();
    }
  }
  checkCameraMoved() {
    const moveDist = this.lastCameraTransform.position.distanceToSquared(this._camera.position);
    const rotateDist = 8 * (1 - this.lastCameraTransform.quaternion.dot(this._camera.quaternion));
    if (moveDist > 1e-6 || rotateDist > 1e-6) {
      this.lastCameraTransform.position.copy(this._camera.position);
      this.lastCameraTransform.quaternion.copy(this._camera.quaternion);
      return true;
    }
    return false;
  }
  render(renderer) {
    this.cameraMovedThisFrame = this.checkCameraMoved();
    this.setVelocityMaterialInScene();
    if (this.renderedMeshesThisFrame > 0 || this.renderedMeshesLastFrame > 0)
      this.renderVelocity(renderer);
    this.unsetVelocityMaterialInScene();
    this.renderedMeshesLastFrame = this.renderedMeshesThisFrame;
  }
};
var zeroVec2 = new Vector2();
var TemporalResolvePass = class extends Pass {
  constructor(scene, camera, customComposeShader, options = {}) {
    super("TemporalResolvePass");
    this.velocityPass = null;
    this.velocityResolutionScale = 1;
    this.samples = 1;
    this.lastCameraTransform = {
      position: new Vector3(),
      quaternion: new Quaternion()
    };
    this._scene = scene;
    this._camera = camera;
    this.renderTarget = new WebGLRenderTarget(1, 1, {
      minFilter: LinearFilter,
      magFilter: LinearFilter,
      type: HalfFloatType,
      depthBuffer: false
    });
    this.velocityPass = new VelocityPass(scene, camera);
    this.fullscreenMaterial = new TemporalResolveMaterial(customComposeShader);
    this.fullscreenMaterial.defines.correctionRadius = options.correctionRadius || 1;
    if (options.dilation)
      this.fullscreenMaterial.defines.dilation = "";
    if (options.boxBlur)
      this.fullscreenMaterial.defines.boxBlur = "";
    this.setupFramebuffers(1, 1);
    this.checkCanUseSharedVelocityTexture();
  }
  dispose() {
    if (this._scene.userData.velocityTexture === this.velocityPass.renderTarget.texture) {
      delete this._scene.userData.velocityTexture;
      delete this._scene.userData.lastVelocityTexture;
    }
    this.renderTarget.dispose();
    this.accumulatedTexture.dispose();
    this.fullscreenMaterial.dispose();
    this.velocityPass.dispose();
  }
  setSize(width, height) {
    this.renderTarget.setSize(width, height);
    this.velocityPass.setSize(width * this.velocityResolutionScale, height * this.velocityResolutionScale);
    this.velocityPass.renderTarget.texture.minFilter = this.velocityResolutionScale === 1 ? NearestFilter : LinearFilter;
    this.velocityPass.renderTarget.texture.magFilter = this.velocityResolutionScale === 1 ? NearestFilter : LinearFilter;
    this.velocityPass.renderTarget.texture.needsUpdate = true;
    this.fullscreenMaterial.uniforms.invTexSize.value.set(1 / width, 1 / height);
    this.setupFramebuffers(width, height);
  }
  setupFramebuffers(width, height) {
    if (this.accumulatedTexture)
      this.accumulatedTexture.dispose();
    if (this.lastVelocityTexture)
      this.lastVelocityTexture.dispose();
    this.accumulatedTexture = new FramebufferTexture(width, height, RGBAFormat);
    this.accumulatedTexture.minFilter = LinearFilter;
    this.accumulatedTexture.magFilter = LinearFilter;
    this.accumulatedTexture.type = HalfFloatType;
    this.lastVelocityTexture = new FramebufferTexture(width * this.velocityResolutionScale, height * this.velocityResolutionScale, RGBAFormat);
    this.lastVelocityTexture.minFilter = this.velocityResolutionScale === 1 ? NearestFilter : LinearFilter;
    this.lastVelocityTexture.magFilter = this.velocityResolutionScale === 1 ? NearestFilter : LinearFilter;
    this.lastVelocityTexture.type = HalfFloatType;
    this.fullscreenMaterial.uniforms.accumulatedTexture.value = this.accumulatedTexture;
    this.fullscreenMaterial.uniforms.lastVelocityTexture.value = this.lastVelocityTexture;
    this.fullscreenMaterial.needsUpdate = true;
  }
  checkCanUseSharedVelocityTexture() {
    const canUseSharedVelocityTexture = this._scene.userData.velocityTexture && this.velocityPass.renderTarget.texture !== this._scene.userData.velocityTexture;
    if (canUseSharedVelocityTexture) {
      if (this.velocityPass.renderTarget.texture === this.fullscreenMaterial.uniforms.velocityTexture.value) {
        this.fullscreenMaterial.uniforms.lastVelocityTexture.value = this._scene.userData.lastVelocityTexture;
        this.fullscreenMaterial.uniforms.velocityTexture.value = this._scene.userData.velocityTexture;
        this.fullscreenMaterial.needsUpdate = true;
      }
    } else {
      if (this.velocityPass.renderTarget.texture !== this.fullscreenMaterial.uniforms.velocityTexture.value) {
        this.fullscreenMaterial.uniforms.velocityTexture.value = this.velocityPass.renderTarget.texture;
        this.fullscreenMaterial.uniforms.lastVelocityTexture.value = this.lastVelocityTexture;
        this.fullscreenMaterial.needsUpdate = true;
        if (!this._scene.userData.velocityTexture) {
          this._scene.userData.velocityTexture = this.velocityPass.renderTarget.texture;
          this._scene.userData.lastVelocityTexture = this.lastVelocityTexture;
        }
      }
    }
    return this.velocityPass.renderTarget.texture !== this.fullscreenMaterial.uniforms.velocityTexture.value;
  }
  checkNeedsResample() {
    const moveDist = this.lastCameraTransform.position.distanceToSquared(this._camera.position);
    const rotateDist = 8 * (1 - this.lastCameraTransform.quaternion.dot(this._camera.quaternion));
    if (moveDist > 1e-6 || rotateDist > 1e-6) {
      this.samples = 1;
      this.lastCameraTransform.position.copy(this._camera.position);
      this.lastCameraTransform.quaternion.copy(this._camera.quaternion);
    }
  }
  render(renderer) {
    this.samples++;
    this.checkNeedsResample();
    this.fullscreenMaterial.uniforms.samples.value = this.samples;
    renderer.setRenderTarget(this.renderTarget);
    renderer.render(this.scene, this.camera);
    renderer.copyFramebufferToTexture(zeroVec2, this.accumulatedTexture);
    renderer.setRenderTarget(this.velocityPass.renderTarget);
    renderer.copyFramebufferToTexture(zeroVec2, this.lastVelocityTexture);
  }
};
var halton = function halton2(index, base) {
  let fraction = 1;
  let result = 0;
  while (index > 0) {
    fraction /= base;
    result += fraction * (index % base);
    index = ~~(index / base);
  }
  return result;
};
var generateHalton23Points = (count) => {
  const data = [];
  let i2 = 1;
  const end = i2 + count;
  for (; i2 < end; i2++) {
    data.push([halton(i2, 2) - 0.5, halton(i2, 3) - 0.5]);
  }
  return data;
};
function escapeRegExp(string) {
  return string.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
}
var worldposReplace = (
  /* glsl */
  `
#if defined( USE_ENVMAP ) || defined(  ) || defined ( USE_SHADOWMAP )
    vec4 worldPosition = modelMatrix * vec4( transformed, 1.0 );

    #ifdef BOX_PROJECTED_ENV_MAP
        vWorldPosition = worldPosition.xyz;
    #endif
#endif
`
);
var boxProjectDefinitions = (
  /* glsl */
  `
#ifdef BOX_PROJECTED_ENV_MAP
    uniform vec3 envMapSize;
    uniform vec3 envMapPosition;
    varying vec3 vWorldPosition;
    
    vec3 parallaxCorrectNormal( vec3 v, vec3 cubeSize, vec3 cubePos ) {
        vec3 nDir = normalize( v );

        vec3 rbmax = ( .5 * cubeSize + cubePos - vWorldPosition ) / nDir;
        vec3 rbmin = ( -.5 * cubeSize + cubePos - vWorldPosition ) / nDir;

        vec3 rbminmax;

        rbminmax.x = ( nDir.x > 0. ) ? rbmax.x : rbmin.x;
        rbminmax.y = ( nDir.y > 0. ) ? rbmax.y : rbmin.y;
        rbminmax.z = ( nDir.z > 0. ) ? rbmax.z : rbmin.z;

        float correction = min( min( rbminmax.x, rbminmax.y ), rbminmax.z );
        vec3 boxIntersection = vWorldPosition + nDir * correction;
        
        return boxIntersection - cubePos;
    }
#endif
`
);
var getIBLIrradiance_patch = (
  /* glsl */
  `
#ifdef BOX_PROJECTED_ENV_MAP
    worldNormal = parallaxCorrectNormal( worldNormal, envMapSize, envMapPosition );
#endif
`
);
var getIBLRadiance_patch = (
  /* glsl */
  `
#ifdef BOX_PROJECTED_ENV_MAP
    reflectVec = parallaxCorrectNormal( reflectVec, envMapSize, envMapPosition );
#endif
`
);
function useBoxProjectedEnvMap(shader, envMapPosition, envMapSize) {
  shader.defines.BOX_PROJECTED_ENV_MAP = "";
  shader.uniforms.envMapPosition = {
    value: envMapPosition
  };
  shader.uniforms.envMapSize = {
    value: envMapSize
  };
  const line1 = new RegExp(escapeRegExp("vec3 worldNormal = inverseTransformDirection ( normal , viewMatrix ) ;").replaceAll(" ", "\\s*"), "g");
  const line2 = new RegExp(escapeRegExp("reflectVec = inverseTransformDirection ( reflectVec , viewMatrix ) ;").replaceAll(" ", "\\s*"), "g");
  shader.vertexShader = "varying vec3 vWorldPosition;\n" + shader.vertexShader.replace("#include <worldpos_vertex>", worldposReplace);
  shader.fragmentShader = boxProjectDefinitions + "\n" + shader.fragmentShader.replace("#include <envmap_physical_pars_fragment>", ShaderChunk.envmap_physical_pars_fragment).replace(line1, `vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
                ${getIBLIrradiance_patch}`).replace(line2, `reflectVec = inverseTransformDirection( reflectVec, viewMatrix );
                ${getIBLRadiance_patch}`);
}
var finalFragmentShader = finalSSRShader.replace("#include <helperFunctions>", helperFunctions).replace("#include <boxBlur>", boxBlur);
var noResetSamplesProperties = ["blur", "blurSharpness", "blurKernel"];
var defaultCubeRenderTarget = new WebGLCubeRenderTarget(1);
var pmremGenerator;
var SSREffect = class extends Effect {
  /**
   * @param {THREE.Scene} scene The scene of the SSR effect
   * @param {THREE.Camera} camera The camera with which SSR is being rendered
   * @param {SSROptions} [options] The optional options for the SSR effect
   */
  constructor(scene, camera, options = defaultSSROptions) {
    super("SSREffect", finalFragmentShader, {
      type: "FinalSSRMaterial",
      uniforms: /* @__PURE__ */ new Map([["reflectionsTexture", new Uniform(null)], ["blur", new Uniform(0)], ["blurSharpness", new Uniform(0)], ["blurKernel", new Uniform(0)]]),
      defines: /* @__PURE__ */ new Map([["RENDER_MODE", "0"]])
    });
    this.haltonSequence = generateHalton23Points(1024);
    this.haltonIndex = 0;
    this.selection = new Selection();
    this.lastSize = void 0;
    this.cubeCamera = new CubeCamera(1e-3, 1e3, defaultCubeRenderTarget);
    this.usingBoxProjectedEnvMap = false;
    this._scene = scene;
    this._camera = camera;
    const trOptions = {
      boxBlur: true,
      dilation: true
    };
    options = _extends({}, defaultSSROptions, options, trOptions);
    this.temporalResolvePass = new TemporalResolvePass(scene, camera, trCompose, options);
    this.uniforms.get("reflectionsTexture").value = this.temporalResolvePass.renderTarget.texture;
    this.reflectionsPass = new ReflectionsPass(this, options);
    this.temporalResolvePass.fullscreenMaterial.uniforms.inputTexture.value = this.reflectionsPass.renderTarget.texture;
    this.lastSize = {
      width: options.width,
      height: options.height,
      resolutionScale: options.resolutionScale,
      velocityResolutionScale: options.velocityResolutionScale
    };
    this.setSize(options.width, options.height);
    this.makeOptionsReactive(options);
  }
  makeOptionsReactive(options) {
    let needsUpdate = false;
    const reflectionPassFullscreenMaterialUniforms = this.reflectionsPass.fullscreenMaterial.uniforms;
    const reflectionPassFullscreenMaterialUniformsKeys = Object.keys(reflectionPassFullscreenMaterialUniforms);
    for (const key of Object.keys(options)) {
      Object.defineProperty(this, key, {
        get() {
          return options[key];
        },
        set(value) {
          if (options[key] === value && needsUpdate)
            return;
          options[key] = value;
          if (!noResetSamplesProperties.includes(key)) {
            this.setSize(this.lastSize.width, this.lastSize.height, true);
          }
          switch (key) {
            case "resolutionScale":
              this.setSize(this.lastSize.width, this.lastSize.height);
              break;
            case "velocityResolutionScale":
              this.temporalResolvePass.velocityResolutionScale = value;
              this.setSize(this.lastSize.width, this.lastSize.height, true);
              break;
            case "blur":
              this.uniforms.get("blur").value = value;
              break;
            case "blurSharpness":
              this.uniforms.get("blurSharpness").value = value;
              break;
            case "blurKernel":
              this.uniforms.get("blurKernel").value = value;
              break;
            case "steps":
              this.reflectionsPass.fullscreenMaterial.defines.steps = parseInt(value);
              this.reflectionsPass.fullscreenMaterial.needsUpdate = needsUpdate;
              break;
            case "refineSteps":
              this.reflectionsPass.fullscreenMaterial.defines.refineSteps = parseInt(value);
              this.reflectionsPass.fullscreenMaterial.needsUpdate = needsUpdate;
              break;
            case "missedRays":
              if (value) {
                this.reflectionsPass.fullscreenMaterial.defines.missedRays = "";
              } else {
                delete this.reflectionsPass.fullscreenMaterial.defines.missedRays;
              }
              this.reflectionsPass.fullscreenMaterial.needsUpdate = needsUpdate;
              break;
            case "correctionRadius":
              this.temporalResolvePass.fullscreenMaterial.defines.correctionRadius = Math.round(value);
              this.temporalResolvePass.fullscreenMaterial.needsUpdate = needsUpdate;
              break;
            case "blend":
              this.temporalResolvePass.fullscreenMaterial.uniforms.blend.value = value;
              break;
            case "correction":
              this.temporalResolvePass.fullscreenMaterial.uniforms.correction.value = value;
              break;
            case "exponent":
              this.temporalResolvePass.fullscreenMaterial.uniforms.exponent.value = value;
              break;
            case "distance":
              reflectionPassFullscreenMaterialUniforms.rayDistance.value = value;
            default:
              if (reflectionPassFullscreenMaterialUniformsKeys.includes(key)) {
                reflectionPassFullscreenMaterialUniforms[key].value = value;
              }
          }
        }
      });
      this[key] = options[key];
    }
    needsUpdate = true;
  }
  setSize(width, height, force = false) {
    if (!force && width === this.lastSize.width && height === this.lastSize.height && this.resolutionScale === this.lastSize.resolutionScale && this.velocityResolutionScale === this.lastSize.velocityResolutionScale)
      return;
    this.temporalResolvePass.setSize(width, height);
    this.reflectionsPass.setSize(width, height);
    this.lastSize = {
      width,
      height,
      resolutionScale: this.resolutionScale,
      velocityResolutionScale: this.velocityResolutionScale
    };
  }
  generateBoxProjectedEnvMapFallback(renderer, position = new Vector3(), size = new Vector3(), envMapSize = 512) {
    this.cubeCamera.renderTarget.dispose();
    this.cubeCamera.renderTarget = new WebGLCubeRenderTarget(envMapSize);
    this.cubeCamera.position.copy(position);
    this.cubeCamera.updateMatrixWorld();
    this.cubeCamera.update(renderer, this._scene);
    if (!pmremGenerator) {
      pmremGenerator = new PMREMGenerator(renderer);
      pmremGenerator.compileCubemapShader();
    }
    const envMap = pmremGenerator.fromCubemap(this.cubeCamera.renderTarget.texture).texture;
    envMap.minFilter = LinearFilter;
    envMap.magFilter = LinearFilter;
    const reflectionsMaterial = this.reflectionsPass.fullscreenMaterial;
    useBoxProjectedEnvMap(reflectionsMaterial, position, size);
    reflectionsMaterial.fragmentShader = reflectionsMaterial.fragmentShader.replace("vec3 worldPos", "worldPos").replace("varying vec3 vWorldPosition;", "vec3 worldPos;");
    reflectionsMaterial.uniforms.envMapPosition.value.copy(position);
    reflectionsMaterial.uniforms.envMapSize.value.copy(size);
    setupEnvMap(reflectionsMaterial, envMap, envMapSize);
    this.usingBoxProjectedEnvMap = true;
    return envMap;
  }
  setIBLRadiance(iblRadiance, renderer) {
    this._scene.traverse((c) => {
      if (c.material) {
        var _renderer$properties$;
        const uniforms = (_renderer$properties$ = renderer.properties.get(c.material)) == null ? void 0 : _renderer$properties$.uniforms;
        if (uniforms && "disableIBLRadiance" in uniforms) {
          uniforms.disableIBLRadiance.value = iblRadiance;
        }
      }
    });
  }
  deleteBoxProjectedEnvMapFallback() {
    const reflectionsMaterial = this.reflectionsPass.fullscreenMaterial;
    reflectionsMaterial.uniforms.envMap.value = null;
    reflectionsMaterial.fragmentShader = reflectionsMaterial.fragmentShader.replace("worldPos = ", "vec3 worldPos = ");
    delete reflectionsMaterial.defines.BOX_PROJECTED_ENV_MAP;
    reflectionsMaterial.needsUpdate = true;
    this.usingBoxProjectedEnvMap = false;
  }
  dispose() {
    super.dispose();
    this.reflectionsPass.dispose();
    this.temporalResolvePass.dispose();
  }
  update(renderer, inputBuffer) {
    if (!this.usingBoxProjectedEnvMap && this._scene.environment) {
      const reflectionsMaterial = this.reflectionsPass.fullscreenMaterial;
      let envMap = null;
      this._scene.traverse((c) => {
        if (!envMap && c.material && !c.material.envMap) {
          const properties = renderer.properties.get(c.material);
          if ("envMap" in properties && properties.envMap instanceof Texture)
            envMap = properties.envMap;
        }
      });
      if (envMap) {
        const envMapCubeUVHeight = this._scene.environment.image.height;
        setupEnvMap(reflectionsMaterial, envMap, envMapCubeUVHeight);
      }
    }
    this.haltonIndex = (this.haltonIndex + 1) % this.haltonSequence.length;
    const [x, y] = this.haltonSequence[this.haltonIndex];
    const {
      width,
      height
    } = this.lastSize;
    this.temporalResolvePass.velocityPass.render(renderer);
    if (this._camera.setViewOffset)
      this._camera.setViewOffset(width, height, x, y, width, height);
    this.reflectionsPass.render(renderer, inputBuffer);
    this.temporalResolvePass.render(renderer);
    this._camera.clearViewOffset();
  }
  static patchDirectEnvIntensity(envMapIntensity = 0) {
    if (envMapIntensity === 0) {
      ShaderChunk.envmap_physical_pars_fragment = ShaderChunk.envmap_physical_pars_fragment.replace("vec3 getIBLRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness ) {", "vec3 getIBLRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness ) { return vec3(0.0);");
    } else {
      ShaderChunk.envmap_physical_pars_fragment = ShaderChunk.envmap_physical_pars_fragment.replace("vec4 envMapColor = textureCubeUV( envMap, reflectVec, roughness );", "vec4 envMapColor = textureCubeUV( envMap, reflectVec, roughness ) * " + envMapIntensity.toFixed(5) + ";");
    }
  }
};

// node_modules/@react-three/postprocessing/dist/index.js
var EffectComposerContext = (0, import_react.createContext)(null);
var EffectComposer2 = import_react.default.memo((0, import_react.forwardRef)(({ children, camera: _camera, scene: _scene, resolutionScale, enabled = true, renderPriority = 1, autoClear = true, depthBuffer, disableNormalPass, stencilBuffer, multisampling = 8, frameBufferType = HalfFloatType }, ref) => {
  const { gl, scene: defaultScene, camera: defaultCamera, size } = useThree();
  const scene = _scene || defaultScene;
  const camera = _camera || defaultCamera;
  const [composer, normalPass, downSamplingPass] = (0, import_react.useMemo)(() => {
    const webGL2Available = isWebGL2Available();
    const effectComposer = new EffectComposer(gl, {
      depthBuffer,
      stencilBuffer,
      multisampling: multisampling > 0 && webGL2Available ? multisampling : 0,
      frameBufferType
    });
    effectComposer.addPass(new RenderPass(scene, camera));
    let downSamplingPass2 = null;
    let normalPass2 = null;
    if (!disableNormalPass) {
      normalPass2 = new NormalPass(scene, camera);
      normalPass2.enabled = false;
      effectComposer.addPass(normalPass2);
      if (resolutionScale !== void 0 && webGL2Available) {
        downSamplingPass2 = new DepthDownsamplingPass({ normalBuffer: normalPass2.texture, resolutionScale });
        downSamplingPass2.enabled = false;
        effectComposer.addPass(downSamplingPass2);
      }
    }
    return [effectComposer, normalPass2, downSamplingPass2];
  }, [
    camera,
    gl,
    depthBuffer,
    stencilBuffer,
    multisampling,
    frameBufferType,
    scene,
    disableNormalPass,
    resolutionScale
  ]);
  (0, import_react.useEffect)(() => composer === null || composer === void 0 ? void 0 : composer.setSize(size.width, size.height), [composer, size]);
  useFrame((_, delta) => {
    if (enabled) {
      gl.autoClear = autoClear;
      composer.render(delta);
    }
  }, enabled ? renderPriority : 0);
  const group = (0, import_react.useRef)(null);
  const instance = useInstanceHandle(group);
  (0, import_react.useLayoutEffect)(() => {
    let effectPass;
    if (group.current && instance.current && composer) {
      effectPass = new EffectPass(camera, ...instance.current.objects);
      effectPass.renderToScreen = true;
      composer.addPass(effectPass);
      if (normalPass)
        normalPass.enabled = true;
      if (downSamplingPass)
        downSamplingPass.enabled = true;
    }
    return () => {
      if (effectPass)
        composer === null || composer === void 0 ? void 0 : composer.removePass(effectPass);
      if (normalPass)
        normalPass.enabled = false;
      if (downSamplingPass)
        downSamplingPass.enabled = false;
    };
  }, [composer, children, camera, normalPass, downSamplingPass, instance]);
  const state = (0, import_react.useMemo)(() => ({ composer, normalPass, downSamplingPass, resolutionScale, camera, scene }), [composer, normalPass, downSamplingPass, resolutionScale, camera, scene]);
  (0, import_react.useImperativeHandle)(ref, () => composer, [composer]);
  return (0, import_jsx_runtime.jsx)(EffectComposerContext.Provider, { value: state, children: (0, import_jsx_runtime.jsx)("group", { ref: group, children }) });
}));
var DepthOfField = (0, import_react.forwardRef)(function DepthOfField2({ target, depthTexture, ...props }, ref) {
  const invalidate = useThree((state) => state.invalidate);
  const { camera } = (0, import_react.useContext)(EffectComposerContext);
  const effect = (0, import_react.useMemo)(() => {
    const effect2 = new DepthOfFieldEffect(camera, props);
    const maskMaterial = effect2.maskPass.getFullscreenMaterial();
    maskMaterial.maskFunction = MaskFunction.MULTIPLY_RGB_SET_ALPHA;
    return effect2;
  }, [camera, props]);
  (0, import_react.useLayoutEffect)(() => {
    if (target && typeof target !== "number") {
      const vec = target instanceof Vector3 ? new Vector3().set(target.x, target.y, target.z) : new Vector3().set(target[0], target[1], target[2]);
      effect.target = vec;
    }
    if (depthTexture)
      effect.setDepthTexture(depthTexture.texture, depthTexture.packing);
    invalidate();
  }, [target, depthTexture, effect]);
  return (0, import_jsx_runtime.jsx)("primitive", { ref, object: effect, dispose: null });
});
var Autofocus = (0, import_react.forwardRef)(({ target = void 0, mouse: followMouse = false, debug = void 0, manual = false, smoothTime = 0.25, ...props }, fref) => {
  const dofRef = (0, import_react.useRef)(null);
  const hitpointRef = (0, import_react.useRef)(null);
  const targetRef = (0, import_react.useRef)(null);
  const scene = useThree(({ scene: scene2 }) => scene2);
  const pointer = useThree(({ pointer: pointer2 }) => pointer2);
  const { composer, camera } = (0, import_react.useContext)(EffectComposerContext);
  const [depthPickingPass] = (0, import_react.useState)(() => new DepthPickingPass());
  const [copyPass] = (0, import_react.useState)(() => new CopyPass());
  (0, import_react.useEffect)(() => {
    composer.addPass(depthPickingPass);
    composer.addPass(copyPass);
    return () => {
      composer.removePass(depthPickingPass);
      composer.removePass(copyPass);
    };
  }, [composer, depthPickingPass, copyPass]);
  (0, import_react.useEffect)(() => {
    return () => {
      depthPickingPass.dispose();
      copyPass.dispose();
    };
  }, [depthPickingPass, copyPass]);
  const [hitpoint] = (0, import_react.useState)(() => new Vector3(0, 0, 0));
  const [ndc] = (0, import_react.useState)(() => new Vector3(0, 0, 0));
  const getHit = (0, import_react.useCallback)(async (x, y) => {
    ndc.x = x;
    ndc.y = y;
    ndc.z = await depthPickingPass.readDepth(ndc);
    ndc.z = ndc.z * 2 - 1;
    const hit = 1 - ndc.z > 1e-7;
    return hit ? ndc.unproject(camera) : false;
  }, [ndc, depthPickingPass, camera]);
  const update = (0, import_react.useCallback)(async (delta, updateTarget = true) => {
    var _a;
    if (target) {
      hitpoint.set(...target);
    } else {
      const { x, y } = followMouse ? pointer : { x: 0, y: 0 };
      const hit = await getHit(x, y);
      if (hit)
        hitpoint.copy(hit);
    }
    if (updateTarget && ((_a = dofRef.current) === null || _a === void 0 ? void 0 : _a.target)) {
      if (smoothTime > 0 && delta > 0) {
        easing.damp3(dofRef.current.target, hitpoint, smoothTime, delta);
      } else {
        dofRef.current.target.copy(hitpoint);
      }
    }
  }, [target, hitpoint, followMouse, getHit, smoothTime, pointer]);
  useFrame(async (_, delta) => {
    var _a;
    if (!manual) {
      update(delta);
    }
    if (hitpointRef.current) {
      hitpointRef.current.position.copy(hitpoint);
    }
    if (targetRef.current && ((_a = dofRef.current) === null || _a === void 0 ? void 0 : _a.target)) {
      targetRef.current.position.copy(dofRef.current.target);
    }
  });
  const api = (0, import_react.useMemo)(() => ({
    dofRef,
    hitpoint,
    update
  }), [hitpoint, update]);
  (0, import_react.useImperativeHandle)(fref, () => api, [api]);
  return (0, import_jsx_runtime.jsxs)(import_jsx_runtime.Fragment, { children: [debug ? createPortal((0, import_jsx_runtime.jsxs)(import_jsx_runtime.Fragment, { children: [(0, import_jsx_runtime.jsxs)("mesh", { ref: hitpointRef, children: [(0, import_jsx_runtime.jsx)("sphereGeometry", { args: [debug, 16, 16] }), (0, import_jsx_runtime.jsx)("meshBasicMaterial", { color: "#00ff00", opacity: 1, transparent: true, depthWrite: false })] }), (0, import_jsx_runtime.jsxs)("mesh", { ref: targetRef, children: [(0, import_jsx_runtime.jsx)("sphereGeometry", { args: [debug / 2, 16, 16] }), (0, import_jsx_runtime.jsx)("meshBasicMaterial", { color: "#00ff00", opacity: 0.5, transparent: true, depthWrite: false })] })] }), scene) : null, (0, import_jsx_runtime.jsx)(DepthOfField, { ref: dofRef, ...props, target: hitpoint })] });
});
var resolveRef = (ref) => typeof ref === "object" && ref != null && "current" in ref ? ref.current : ref;
var i = 0;
var components = /* @__PURE__ */ new WeakMap();
var wrapEffect = (effect, defaults) => import_react.default.forwardRef(function Effect2({ blendFunction = defaults === null || defaults === void 0 ? void 0 : defaults.blendFunction, opacity = defaults === null || defaults === void 0 ? void 0 : defaults.opacity, ...props }, ref) {
  let Component = components.get(effect);
  if (!Component) {
    const key = `@react-three/postprocessing/${effect.name}-${i++}`;
    extend({ [key]: effect });
    components.set(effect, Component = key);
  }
  const camera = useThree((state) => state.camera);
  const args = import_react.default.useMemo(
    () => {
      var _a, _b;
      return [...(_a = defaults === null || defaults === void 0 ? void 0 : defaults.args) !== null && _a !== void 0 ? _a : [], ...(_b = props.args) !== null && _b !== void 0 ? _b : [{ ...defaults, ...props }]];
    },
    // eslint-disable-next-line react-hooks/exhaustive-deps
    [JSON.stringify(props)]
  );
  return (0, import_jsx_runtime.jsx)(Component, { camera, "blendMode-blendFunction": blendFunction, "blendMode-opacity-value": opacity, ...props, ref, args });
});
var useVector2 = (props, key) => {
  const value = props[key];
  return import_react.default.useMemo(() => {
    if (typeof value === "number")
      return new Vector2(value, value);
    else if (value)
      return new Vector2(...value);
    else
      return new Vector2();
  }, [value]);
};
var Bloom = wrapEffect(BloomEffect, {
  blendFunction: BlendFunction.ADD
});
var BrightnessContrast = wrapEffect(BrightnessContrastEffect);
var ChromaticAberration = (0, import_react.forwardRef)(function ChromaticAberration2(props, ref) {
  const offset = useVector2(props, "offset");
  const effect = (0, import_react.useMemo)(() => new ChromaticAberrationEffect({ ...props, offset }), [offset, props]);
  return (0, import_jsx_runtime.jsx)("primitive", { ref, object: effect, dispose: null });
});
var ColorAverage = (0, import_react.forwardRef)(function ColorAverage2({ blendFunction = BlendFunction.NORMAL }, ref) {
  const effect = (0, import_react.useMemo)(() => new ColorAverageEffect(blendFunction), [blendFunction]);
  return (0, import_jsx_runtime.jsx)("primitive", { ref, object: effect, dispose: null });
});
var ColorDepth = wrapEffect(ColorDepthEffect);
var Depth = wrapEffect(DepthEffect);
var DotScreen = wrapEffect(DotScreenEffect);
var Glitch = (0, import_react.forwardRef)(function Glitch2({ active = true, ...props }, ref) {
  const invalidate = useThree((state) => state.invalidate);
  const delay = useVector2(props, "delay");
  const duration = useVector2(props, "duration");
  const strength = useVector2(props, "strength");
  const effect = (0, import_react.useMemo)(() => new GlitchEffect({ ...props, delay, duration, strength }), [delay, duration, props, strength]);
  (0, import_react.useLayoutEffect)(() => {
    effect.mode = active ? props.mode || GlitchMode.SPORADIC : GlitchMode.DISABLED;
    invalidate();
  }, [active, effect, invalidate, props.mode]);
  return (0, import_jsx_runtime.jsx)("primitive", { ref, object: effect, dispose: null });
});
var GodRays = (0, import_react.forwardRef)(function GodRays2(props, ref) {
  const { camera } = (0, import_react.useContext)(EffectComposerContext);
  const effect = (0, import_react.useMemo)(() => new GodRaysEffect(camera, resolveRef(props.sun), props), [camera, props]);
  (0, import_react.useLayoutEffect)(() => void (effect.lightSource = resolveRef(props.sun)), [effect, props.sun]);
  return (0, import_jsx_runtime.jsx)("primitive", { ref, object: effect, dispose: null });
});
var Grid = (0, import_react.forwardRef)(function Grid2({ size, ...props }, ref) {
  const invalidate = useThree((state) => state.invalidate);
  const effect = (0, import_react.useMemo)(() => new GridEffect(props), [props]);
  (0, import_react.useLayoutEffect)(() => {
    if (size)
      effect.setSize(size.width, size.height);
    invalidate();
  }, [effect, size]);
  return (0, import_jsx_runtime.jsx)("primitive", { ref, object: effect, dispose: null });
});
var HueSaturation = wrapEffect(HueSaturationEffect);
var Noise = wrapEffect(NoiseEffect, { blendFunction: BlendFunction.COLOR_DODGE });
var selectionContext = (0, import_react.createContext)(null);
function Selection2({ children, enabled = true }) {
  const [selected, select] = (0, import_react.useState)([]);
  const value = (0, import_react.useMemo)(() => ({ selected, select, enabled }), [selected, select, enabled]);
  return (0, import_jsx_runtime.jsx)(selectionContext.Provider, { value, children });
}
function Select({ enabled = false, children, ...props }) {
  const group = (0, import_react.useRef)(null);
  const api = (0, import_react.useContext)(selectionContext);
  (0, import_react.useEffect)(() => {
    if (api && enabled) {
      let changed = false;
      const current = [];
      group.current.traverse((o) => {
        o.type === "Mesh" && current.push(o);
        if (api.selected.indexOf(o) === -1)
          changed = true;
      });
      if (changed) {
        api.select((state) => [...state, ...current]);
        return () => {
          api.select((state) => state.filter((selected) => !current.includes(selected)));
        };
      }
    }
  }, [enabled, children, api]);
  return (0, import_jsx_runtime.jsx)("group", { ref: group, ...props, children });
}
var Outline = (0, import_react.forwardRef)(function Outline2({ selection = [], selectionLayer = 10, blendFunction, patternTexture, edgeStrength, pulseSpeed, visibleEdgeColor, hiddenEdgeColor, width, height, kernelSize, blur, xRay, ...props }, forwardRef2) {
  const invalidate = useThree((state) => state.invalidate);
  const { scene, camera } = (0, import_react.useContext)(EffectComposerContext);
  const effect = (0, import_react.useMemo)(() => new OutlineEffect(scene, camera, {
    blendFunction,
    patternTexture,
    edgeStrength,
    pulseSpeed,
    visibleEdgeColor,
    hiddenEdgeColor,
    width,
    height,
    kernelSize,
    blur,
    xRay,
    ...props
  }), [
    blendFunction,
    blur,
    camera,
    edgeStrength,
    height,
    hiddenEdgeColor,
    kernelSize,
    patternTexture,
    props,
    pulseSpeed,
    scene,
    visibleEdgeColor,
    width,
    xRay
  ]);
  const api = (0, import_react.useContext)(selectionContext);
  (0, import_react.useEffect)(() => {
    if (!api && selection) {
      effect.selection.set(Array.isArray(selection) ? selection.map(resolveRef) : [resolveRef(selection)]);
      invalidate();
      return () => {
        effect.selection.clear();
        invalidate();
      };
    }
  }, [effect, selection, api, invalidate]);
  (0, import_react.useEffect)(() => {
    effect.selectionLayer = selectionLayer;
    invalidate();
  }, [effect, invalidate, selectionLayer]);
  (0, import_react.useRef)();
  (0, import_react.useEffect)(() => {
    var _a;
    if (api && api.enabled) {
      if ((_a = api.selected) === null || _a === void 0 ? void 0 : _a.length) {
        effect.selection.set(api.selected);
        invalidate();
        return () => {
          effect.selection.clear();
          invalidate();
        };
      }
    }
  }, [api, effect.selection, invalidate]);
  return (0, import_jsx_runtime.jsx)("primitive", { ref: forwardRef2, object: effect });
});
var Pixelation = (0, import_react.forwardRef)(function Pixelation2({ granularity = 5 }, ref) {
  const effect = (0, import_react.useMemo)(() => new PixelationEffect(granularity), [granularity]);
  return (0, import_jsx_runtime.jsx)("primitive", { ref, object: effect, dispose: null });
});
var Scanline = wrapEffect(ScanlineEffect, { blendFunction: BlendFunction.OVERLAY, density: 1.25 });
var addLight = (light, effect) => light.layers.enable(effect.selection.layer);
var removeLight = (light, effect) => light.layers.disable(effect.selection.layer);
var SelectiveBloom = (0, import_react.forwardRef)(function SelectiveBloom2({ selection = [], selectionLayer = 10, lights = [], luminanceThreshold, luminanceSmoothing, intensity, width, height, kernelSize, mipmapBlur, ...props }, forwardRef2) {
  if (lights.length === 0) {
    console.warn("SelectiveBloom requires lights to work.");
  }
  const invalidate = useThree((state) => state.invalidate);
  const { scene, camera } = (0, import_react.useContext)(EffectComposerContext);
  const effect = (0, import_react.useMemo)(() => new SelectiveBloomEffect(scene, camera, {
    blendFunction: BlendFunction.ADD,
    luminanceThreshold,
    luminanceSmoothing,
    intensity,
    width,
    height,
    kernelSize,
    mipmapBlur,
    ...props
  }), [scene, camera, luminanceThreshold, luminanceSmoothing, intensity, width, height, kernelSize, mipmapBlur, props]);
  const api = (0, import_react.useContext)(selectionContext);
  (0, import_react.useEffect)(() => {
    if (!api && selection) {
      effect.selection.set(Array.isArray(selection) ? selection.map(resolveRef) : [resolveRef(selection)]);
      invalidate();
      return () => {
        effect.selection.clear();
        invalidate();
      };
    }
  }, [effect, selection, api, invalidate]);
  (0, import_react.useEffect)(() => {
    effect.selection.layer = selectionLayer;
    invalidate();
  }, [effect, invalidate, selectionLayer]);
  (0, import_react.useEffect)(() => {
    if (lights && lights.length > 0) {
      lights.forEach((light) => addLight(resolveRef(light), effect));
      invalidate();
      return () => {
        lights.forEach((light) => removeLight(resolveRef(light), effect));
        invalidate();
      };
    }
  }, [effect, invalidate, lights, selectionLayer]);
  (0, import_react.useEffect)(() => {
    var _a;
    if (api && api.enabled) {
      if ((_a = api.selected) === null || _a === void 0 ? void 0 : _a.length) {
        effect.selection.set(api.selected);
        invalidate();
        return () => {
          effect.selection.clear();
          invalidate();
        };
      }
    }
  }, [api, effect.selection, invalidate]);
  return (0, import_jsx_runtime.jsx)("primitive", { ref: forwardRef2, object: effect, dispose: null });
});
var Sepia = wrapEffect(SepiaEffect);
var SSAO = (0, import_react.forwardRef)(function SSAO2(props, ref) {
  const { camera, normalPass, downSamplingPass, resolutionScale } = (0, import_react.useContext)(EffectComposerContext);
  const effect = (0, import_react.useMemo)(() => {
    if (normalPass === null && downSamplingPass === null) {
      console.error("Please enable the NormalPass in the EffectComposer in order to use SSAO.");
      return {};
    }
    return new SSAOEffect(camera, normalPass && !downSamplingPass ? normalPass.texture : null, {
      blendFunction: BlendFunction.MULTIPLY,
      samples: 30,
      rings: 4,
      distanceThreshold: 1,
      distanceFalloff: 0,
      rangeThreshold: 0.5,
      rangeFalloff: 0.1,
      luminanceInfluence: 0.9,
      radius: 20,
      bias: 0.5,
      intensity: 1,
      color: void 0,
      // @ts-ignore
      normalDepthBuffer: downSamplingPass ? downSamplingPass.texture : null,
      resolutionScale: resolutionScale !== null && resolutionScale !== void 0 ? resolutionScale : 1,
      depthAwareUpsampling: true,
      ...props
    });
  }, [camera, normalPass, props]);
  return (0, import_jsx_runtime.jsx)("primitive", { ref, object: effect, dispose: null });
});
var SMAA = wrapEffect(SMAAEffect);
var Texture2 = (0, import_react.forwardRef)(function Texture3({ textureSrc, texture, ...props }, ref) {
  const t = useLoader(TextureLoader, textureSrc);
  (0, import_react.useLayoutEffect)(() => {
    t.encoding = sRGBEncoding;
    t.wrapS = t.wrapT = RepeatWrapping;
  }, [t]);
  const effect = (0, import_react.useMemo)(() => new TextureEffect({ ...props, texture: t || texture }), [props, t, texture]);
  return (0, import_jsx_runtime.jsx)("primitive", { ref, object: effect, dispose: null });
});
var ToneMapping = wrapEffect(ToneMappingEffect);
var Vignette = wrapEffect(VignetteEffect);
var ShockWave = wrapEffect(ShockWaveEffect);
var LUT = (0, import_react.forwardRef)(function LUT2({ lut, tetrahedralInterpolation, ...props }, ref) {
  const effect = (0, import_react.useMemo)(() => new LUT3DEffect(lut, props), [lut, props]);
  const invalidate = useThree((state) => state.invalidate);
  (0, import_react.useLayoutEffect)(() => {
    if (tetrahedralInterpolation)
      effect.tetrahedralInterpolation = tetrahedralInterpolation;
    if (lut)
      effect.lut = lut;
    invalidate();
  }, [effect, invalidate, lut, tetrahedralInterpolation]);
  return (0, import_jsx_runtime.jsx)("primitive", { ref, object: effect, dispose: null });
});
var TiltShift = wrapEffect(TiltShiftEffect, { blendFunction: BlendFunction.ADD });
var TiltShiftShader = {
  fragmentShader: `

    // original shader by Evan Wallace

    #define MAX_ITERATIONS 100

    uniform float blur;
    uniform float taper;
    uniform vec2 start;
    uniform vec2 end;
    uniform vec2 direction;
    uniform int samples;

    float random(vec3 scale, float seed) {
        /* use the fragment position for a different seed per-pixel */
        return fract(sin(dot(gl_FragCoord.xyz + seed, scale)) * 43758.5453 + seed);
    }

    void mainImage(const in vec4 inputColor, const in vec2 uv, out vec4 outputColor) {
        vec4 color = vec4(0.0);
        float total = 0.0;
        vec2 startPixel = vec2(start.x * resolution.x, start.y * resolution.y);
        vec2 endPixel = vec2(end.x * resolution.x, end.y * resolution.y);
        float f_samples = float(samples);
        float half_samples = f_samples / 2.0;

        // use screen diagonal to normalize blur radii
        float maxScreenDistance = distance(vec2(0.0), resolution); // diagonal distance
        float gradientRadius = taper * (maxScreenDistance);
        float blurRadius = blur * (maxScreenDistance / 16.0);

        /* randomize the lookup values to hide the fixed number of samples */
        float offset = random(vec3(12.9898, 78.233, 151.7182), 0.0);
        vec2 normal = normalize(vec2(startPixel.y - endPixel.y, endPixel.x - startPixel.x));
        float radius = smoothstep(0.0, 1.0, abs(dot(uv * resolution - startPixel, normal)) / gradientRadius) * blurRadius;

        #pragma unroll_loop_start
        for (int i = 0; i <= MAX_ITERATIONS; i++) {
            if (i >= samples) { break; } // return early if over sample count
            float f_i = float(i);
            float s_i = -half_samples + f_i;
            float percent = (s_i + offset - 0.5) / half_samples;
            float weight = 1.0 - abs(percent);
            vec4 sample_i = texture2D(inputBuffer, uv + normalize(direction) / resolution * percent * radius);
            /* switch to pre-multiplied alpha to correctly blur transparent images */
            sample_i.rgb *= sample_i.a;
            color += sample_i * weight;
            total += weight;
        }
        #pragma unroll_loop_end

        outputColor = color / total;

        /* switch back from pre-multiplied alpha */
        outputColor.rgb /= outputColor.a + 0.00001;
    }
    `
};
var TiltShiftEffect2 = class extends Effect {
  constructor({
    blendFunction = BlendFunction.NORMAL,
    blur = 0.15,
    // [0, 1], can go beyond 1 for extra
    taper = 0.5,
    // [0, 1], can go beyond 1 for extra
    start = [0.5, 0],
    // [0,1] percentage x,y of screenspace
    end = [0.5, 1],
    // [0,1] percentage x,y of screenspace
    samples = 10,
    // number of blur samples
    direction = [1, 1]
    // direction of blur
  } = {}) {
    super("TiltShiftEffect", TiltShiftShader.fragmentShader, {
      blendFunction,
      attributes: EffectAttribute.CONVOLUTION,
      uniforms: /* @__PURE__ */ new Map([
        ["blur", new Uniform(blur)],
        ["taper", new Uniform(taper)],
        ["start", new Uniform(start)],
        ["end", new Uniform(end)],
        ["samples", new Uniform(samples)],
        ["direction", new Uniform(direction)]
      ])
    });
  }
};
var TiltShift2 = wrapEffect(TiltShiftEffect2, { blendFunction: BlendFunction.NORMAL });
var SSR = (0, import_react.forwardRef)(function SSR2({ ENABLE_BLUR = true, USE_MRT = true, ...props }, ref) {
  const { invalidate } = useThree();
  const { scene, camera } = (0, import_react.useContext)(EffectComposerContext);
  const effect = (0, import_react.useMemo)(() => new SSREffect(scene, camera, { ENABLE_BLUR, USE_MRT, ...props }), [scene, camera, ENABLE_BLUR, USE_MRT, props]);
  const api = (0, import_react.useContext)(selectionContext);
  (0, import_react.useEffect)(() => {
    var _a;
    if (api && api.enabled) {
      if ((_a = api.selected) === null || _a === void 0 ? void 0 : _a.length) {
        effect.selection.set(api.selected);
        invalidate();
        return () => {
          effect.selection.clear();
          invalidate();
        };
      }
    }
  }, [api]);
  return (0, import_jsx_runtime.jsx)("primitive", { ref, object: effect, ...props });
});
export {
  Autofocus,
  Bloom,
  BrightnessContrast,
  ChromaticAberration,
  ColorAverage,
  ColorDepth,
  Depth,
  DepthOfField,
  DotScreen,
  EffectComposer2 as EffectComposer,
  EffectComposerContext,
  Glitch,
  GodRays,
  Grid,
  HueSaturation,
  LUT,
  Noise,
  Outline,
  Pixelation,
  SMAA,
  SSAO,
  SSR,
  Scanline,
  Select,
  Selection2 as Selection,
  SelectiveBloom,
  Sepia,
  ShockWave,
  Texture2 as Texture,
  TiltShift,
  TiltShift2,
  TiltShiftEffect2 as TiltShiftEffect,
  ToneMapping,
  Vignette,
  resolveRef,
  selectionContext,
  useVector2,
  wrapEffect
};
/*! Bundled license information:

react/cjs/react-jsx-runtime.development.js:
  (**
   * @license React
   * react-jsx-runtime.development.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)
*/
//# sourceMappingURL=@react-three_postprocessing.js.map
